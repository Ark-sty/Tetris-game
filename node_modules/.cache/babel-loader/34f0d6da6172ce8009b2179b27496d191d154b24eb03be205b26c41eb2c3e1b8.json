{"ast":null,"code":"var _jsxFileName = \"D:\\\\MyGame\\\\src\\\\components\\\\TetrisGame.tsx\",\n  _s = $RefreshSig$();\n// (생략된 import 및 기본 설정은 유지)\n\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\n\n// 테트리스 블록 타입 정의\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 블록 모양 정의\nconst BLOCKS = {\n  I: [[1, 1, 1, 1]],\n  O: [[1, 1], [1, 1]],\n  T: [[0, 1, 0], [1, 1, 1]],\n  L: [[1, 0], [1, 0], [1, 1]],\n  J: [[0, 1], [0, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0]],\n  Z: [[1, 1, 0], [0, 1, 1]]\n};\n\n// 블록 색상 정의\nconst COLORS = {\n  I: '#00f0f0',\n  O: '#f0f000',\n  T: '#a000f0',\n  L: '#f0a000',\n  J: '#0000f0',\n  S: '#00f000',\n  Z: '#f00000'\n};\n\n// 게임 보드 크기\nconst BOARD_WIDTH = 10;\nconst BOARD_HEIGHT = 20;\nconst BLOCK_SIZE = 30;\nconst TetrisGame = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [gameOver, setGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [lockDelayTimer, setLockDelayTimer] = useState(null);\n  const [board, setBoard] = useState(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n  const [currentBlock, setCurrentBlock] = useState(null);\n  const createNewBlock = useCallback(() => {\n    const types = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\n    const type = types[Math.floor(Math.random() * types.length)];\n    const shape = BLOCKS[type];\n    setCurrentBlock({\n      type,\n      position: {\n        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),\n        y: 0\n      },\n      shape\n    });\n  }, []);\n  const handleGameOver = useCallback(() => {\n    setGameOver(true);\n    setIsPlaying(false);\n    setScore(0);\n  }, []);\n  const startGame = useCallback(() => {\n    setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n    setScore(0);\n    setGameOver(false);\n    setIsPlaying(true);\n    createNewBlock();\n  }, [createNewBlock]);\n  const isValidMove = useCallback((position, shape) => {\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = position.x + x;\n          const boardY = position.y + y;\n          if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || boardY >= 0 && board[boardY][boardX]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }, [board]);\n  const placeBlock = useCallback(() => {\n    if (!currentBlock) return;\n    const newBoard = [...board];\n    for (let y = 0; y < currentBlock.shape.length; y++) {\n      for (let x = 0; x < currentBlock.shape[y].length; x++) {\n        if (currentBlock.shape[y][x]) {\n          const boardY = currentBlock.position.y + y;\n          const boardX = currentBlock.position.x + x;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, createNewBlock, handleGameOver]);\n  const isTouchingGround = useCallback(() => {\n    if (!currentBlock) return false;\n    const testPosition = {\n      x: currentBlock.position.x,\n      y: currentBlock.position.y + 1\n    };\n    return !isValidMove(testPosition, currentBlock.shape);\n  }, [currentBlock, isValidMove]);\n  const moveBlock = useCallback((dx, dy) => {\n    if (!currentBlock || gameOver) return;\n    const newPosition = {\n      x: currentBlock.position.x + dx,\n      y: currentBlock.position.y + dy\n    };\n    if (isValidMove(newPosition, currentBlock.shape)) {\n      setCurrentBlock({\n        ...currentBlock,\n        position: newPosition\n      });\n      if (dy !== 0 && isTouchingGround()) {\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (lockDelayTimer) {\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    } else if (dy > 0) {\n      if (!lockDelayTimer) {\n        const timer = setTimeout(() => {\n          placeBlock();\n          setLockDelayTimer(null);\n        }, 500);\n        setLockDelayTimer(timer);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\n  const rotateBlock = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    const rotated = currentBlock.shape[0].map((_, i) => currentBlock.shape.map(row => row[i]).reverse());\n    if (isValidMove(currentBlock.position, rotated)) {\n      setCurrentBlock({\n        ...currentBlock,\n        shape: rotated\n      });\n      if (isTouchingGround()) {\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (lockDelayTimer) {\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\n  const checkLines = useCallback(newBoard => {\n    let linesCleared = 0;\n    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\n      if (newBoard[y].every(cell => cell === 1)) {\n        newBoard.splice(y, 1);\n        newBoard.unshift(Array(BOARD_WIDTH).fill(0));\n        linesCleared++;\n        y++;\n      }\n    }\n    if (linesCleared > 0) {\n      setScore(prev => prev + linesCleared * 100);\n      setBoard(newBoard);\n    }\n  }, []);\n  const hardDrop = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    let dropDistance = 0;\n    const shape = currentBlock.shape;\n    const startPosition = currentBlock.position;\n    while (isValidMove({\n      x: startPosition.x,\n      y: startPosition.y + dropDistance + 1\n    }, shape)) {\n      dropDistance++;\n    }\n    const finalPosition = {\n      x: startPosition.x,\n      y: startPosition.y + dropDistance\n    };\n    const newBoard = [...board];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = finalPosition.x + x;\n          const boardY = finalPosition.y + y;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\n  useEffect(() => {\n    if (!isPlaying) return;\n    const dropInterval = setInterval(() => {\n      moveBlock(0, 1);\n    }, 1000);\n    return () => clearInterval(dropInterval);\n  }, [isPlaying, moveBlock]);\n  useEffect(() => {\n    const handleKeyPress = e => {\n      if (!isPlaying) return;\n      switch (e.key) {\n        case 'ArrowLeft':\n          moveBlock(-1, 0);\n          break;\n        case 'ArrowRight':\n          moveBlock(1, 0);\n          break;\n        case 'ArrowDown':\n          moveBlock(0, 1);\n          break;\n        case 'ArrowUp':\n          rotateBlock();\n          break;\n        case ' ':\n          hardDrop();\n          break;\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        if (board[y][x]) {\n          ctx.fillStyle = '#666';\n          ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n        }\n      }\n    }\n    if (currentBlock) {\n      ctx.fillStyle = COLORS[currentBlock.type];\n      for (let y = 0; y < currentBlock.shape.length; y++) {\n        for (let x = 0; x < currentBlock.shape[y].length; x++) {\n          if (currentBlock.shape[y][x]) {\n            ctx.fillRect((currentBlock.position.x + x) * BLOCK_SIZE, (currentBlock.position.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n          }\n        }\n      }\n    }\n  }, [board, currentBlock]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"text-4xl font-bold mb-4\",\n      children: \"\\uD14C\\uD2B8\\uB9AC\\uC2A4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 325,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xl\",\n        children: [\"\\uC810\\uC218: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 327,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 326,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: BOARD_WIDTH * BLOCK_SIZE,\n      height: BOARD_HEIGHT * BLOCK_SIZE,\n      className: \"border-2 border-gray-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 329,\n      columnNumber: 13\n    }, this), !isPlaying && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startGame,\n      className: \"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\",\n      children: gameOver ? '다시 시작' : '게임 시작'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 336,\n      columnNumber: 17\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 text-red-500 text-xl\",\n      children: \"\\uAC8C\\uC784 \\uC624\\uBC84!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 344,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 324,\n    columnNumber: 9\n  }, this);\n};\n_s(TetrisGame, \"jsLbSp9hDR3dRLsEs0+IrRt5dW8=\");\n_c = TetrisGame;\nexport default TetrisGame;\nvar _c;\n$RefreshReg$(_c, \"TetrisGame\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","BLOCKS","I","O","T","L","J","S","Z","COLORS","BOARD_WIDTH","BOARD_HEIGHT","BLOCK_SIZE","TetrisGame","_s","canvasRef","gameOver","setGameOver","score","setScore","isPlaying","setIsPlaying","lockDelayTimer","setLockDelayTimer","board","setBoard","Array","fill","map","currentBlock","setCurrentBlock","createNewBlock","types","type","Math","floor","random","length","shape","position","x","y","handleGameOver","startGame","isValidMove","boardX","boardY","placeBlock","newBoard","checkLines","isTouchingGround","testPosition","moveBlock","dx","dy","newPosition","timer","setTimeout","clearTimeout","rotateBlock","rotated","_","i","row","reverse","linesCleared","every","cell","splice","unshift","prev","hardDrop","dropDistance","startPosition","finalPosition","dropInterval","setInterval","clearInterval","handleKeyPress","e","key","window","addEventListener","removeEventListener","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","className","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","onClick","_c","$RefreshReg$"],"sources":["D:/MyGame/src/components/TetrisGame.tsx"],"sourcesContent":["// (생략된 import 및 기본 설정은 유지)\r\n\r\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\n// 테트리스 블록 타입 정의\r\ntype BlockType = 'I' | 'O' | 'T' | 'L' | 'J' | 'S' | 'Z';\r\n\r\n// 블록 모양 정의\r\nconst BLOCKS = {\r\n    I: [[1, 1, 1, 1]],\r\n    O: [[1, 1], [1, 1]],\r\n    T: [[0, 1, 0], [1, 1, 1]],\r\n    L: [[1, 0], [1, 0], [1, 1]],\r\n    J: [[0, 1], [0, 1], [1, 1]],\r\n    S: [[0, 1, 1], [1, 1, 0]],\r\n    Z: [[1, 1, 0], [0, 1, 1]]\r\n};\r\n\r\n// 블록 색상 정의\r\nconst COLORS = {\r\n    I: '#00f0f0',\r\n    O: '#f0f000',\r\n    T: '#a000f0',\r\n    L: '#f0a000',\r\n    J: '#0000f0',\r\n    S: '#00f000',\r\n    Z: '#f00000'\r\n};\r\n\r\n// 게임 보드 크기\r\nconst BOARD_WIDTH = 10;\r\nconst BOARD_HEIGHT = 20;\r\nconst BLOCK_SIZE = 30;\r\n\r\nconst TetrisGame: React.FC = () => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [score, setScore] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [lockDelayTimer, setLockDelayTimer] = useState<NodeJS.Timeout | null>(null);\r\n\r\n    const [board, setBoard] = useState<number[][]>(\r\n        Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0))\r\n    );\r\n    const [currentBlock, setCurrentBlock] = useState<{\r\n        type: BlockType;\r\n        position: { x: number; y: number };\r\n        shape: number[][];\r\n    } | null>(null);\r\n\r\n    const createNewBlock = useCallback(() => {\r\n        const types: BlockType[] = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\r\n        const type = types[Math.floor(Math.random() * types.length)];\r\n        const shape = BLOCKS[type];\r\n\r\n        setCurrentBlock({\r\n            type,\r\n            position: { x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2), y: 0 },\r\n            shape\r\n        });\r\n    }, []);\r\n\r\n    const handleGameOver = useCallback(() => {\r\n        setGameOver(true);\r\n        setIsPlaying(false);\r\n        setScore(0);\r\n    }, []);\r\n\r\n    const startGame = useCallback(() => {\r\n        setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\r\n        setScore(0);\r\n        setGameOver(false);\r\n        setIsPlaying(true);\r\n        createNewBlock();\r\n    }, [createNewBlock]);\r\n\r\n    const isValidMove = useCallback((position: { x: number; y: number }, shape: number[][]) => {\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = position.x + x;\r\n                    const boardY = position.y + y;\r\n\r\n                    if (\r\n                        boardX < 0 ||\r\n                        boardX >= BOARD_WIDTH ||\r\n                        boardY >= BOARD_HEIGHT ||\r\n                        (boardY >= 0 && board[boardY][boardX])\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }, [board]);\r\n\r\n    const placeBlock = useCallback(() => {\r\n        if (!currentBlock) return;\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < currentBlock.shape.length; y++) {\r\n            for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                if (currentBlock.shape[y][x]) {\r\n                    const boardY = currentBlock.position.y + y;\r\n                    const boardX = currentBlock.position.x + x;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, createNewBlock, handleGameOver]);\r\n\r\n    const isTouchingGround = useCallback(() => {\r\n        if (!currentBlock) return false;\r\n        const testPosition = {\r\n            x: currentBlock.position.x,\r\n            y: currentBlock.position.y + 1\r\n        };\r\n        return !isValidMove(testPosition, currentBlock.shape);\r\n    }, [currentBlock, isValidMove]);\r\n\r\n    const moveBlock = useCallback((dx: number, dy: number) => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const newPosition = {\r\n            x: currentBlock.position.x + dx,\r\n            y: currentBlock.position.y + dy\r\n        };\r\n\r\n        if (isValidMove(newPosition, currentBlock.shape)) {\r\n            setCurrentBlock({ ...currentBlock, position: newPosition });\r\n\r\n            if (dy !== 0 && isTouchingGround()) {\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (lockDelayTimer) {\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        } else if (dy > 0) {\r\n            if (!lockDelayTimer) {\r\n                const timer = setTimeout(() => {\r\n                    placeBlock();\r\n                    setLockDelayTimer(null);\r\n                }, 500);\r\n                setLockDelayTimer(timer);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\r\n\r\n    const rotateBlock = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const rotated = currentBlock.shape[0].map((_, i) =>\r\n            currentBlock.shape.map(row => row[i]).reverse()\r\n        );\r\n\r\n        if (isValidMove(currentBlock.position, rotated)) {\r\n            setCurrentBlock({ ...currentBlock, shape: rotated });\r\n\r\n            if (isTouchingGround()) {\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (lockDelayTimer) {\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\r\n\r\n    const checkLines = useCallback((newBoard: number[][]) => {\r\n        let linesCleared = 0;\r\n\r\n        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\r\n            if (newBoard[y].every(cell => cell === 1)) {\r\n                newBoard.splice(y, 1);\r\n                newBoard.unshift(Array(BOARD_WIDTH).fill(0));\r\n                linesCleared++;\r\n                y++;\r\n            }\r\n        }\r\n\r\n        if (linesCleared > 0) {\r\n            setScore(prev => prev + linesCleared * 100);\r\n            setBoard(newBoard);\r\n        }\r\n    }, []);\r\n\r\n    const hardDrop = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        let dropDistance = 0;\r\n        const shape = currentBlock.shape;\r\n        const startPosition = currentBlock.position;\r\n\r\n        while (isValidMove({ x: startPosition.x, y: startPosition.y + dropDistance + 1 }, shape)) {\r\n            dropDistance++;\r\n        }\r\n\r\n        const finalPosition = {\r\n            x: startPosition.x,\r\n            y: startPosition.y + dropDistance\r\n        };\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = finalPosition.x + x;\r\n                    const boardY = finalPosition.y + y;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\r\n\r\n    useEffect(() => {\r\n        if (!isPlaying) return;\r\n\r\n        const dropInterval = setInterval(() => {\r\n            moveBlock(0, 1);\r\n        }, 1000);\r\n\r\n        return () => clearInterval(dropInterval);\r\n    }, [isPlaying, moveBlock]);\r\n\r\n    useEffect(() => {\r\n        const handleKeyPress = (e: KeyboardEvent) => {\r\n            if (!isPlaying) return;\r\n\r\n            switch (e.key) {\r\n                case 'ArrowLeft':\r\n                    moveBlock(-1, 0);\r\n                    break;\r\n                case 'ArrowRight':\r\n                    moveBlock(1, 0);\r\n                    break;\r\n                case 'ArrowDown':\r\n                    moveBlock(0, 1);\r\n                    break;\r\n                case 'ArrowUp':\r\n                    rotateBlock();\r\n                    break;\r\n                case ' ':\r\n                    hardDrop();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyPress);\r\n        return () => window.removeEventListener('keydown', handleKeyPress);\r\n    }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        for (let y = 0; y < BOARD_HEIGHT; y++) {\r\n            for (let x = 0; x < BOARD_WIDTH; x++) {\r\n                if (board[y][x]) {\r\n                    ctx.fillStyle = '#666';\r\n                    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentBlock) {\r\n            ctx.fillStyle = COLORS[currentBlock.type];\r\n            for (let y = 0; y < currentBlock.shape.length; y++) {\r\n                for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                    if (currentBlock.shape[y][x]) {\r\n                        ctx.fillRect(\r\n                            (currentBlock.position.x + x) * BLOCK_SIZE,\r\n                            (currentBlock.position.y + y) * BLOCK_SIZE,\r\n                            BLOCK_SIZE - 1,\r\n                            BLOCK_SIZE - 1\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [board, currentBlock]);\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\">\r\n            <h1 className=\"text-4xl font-bold mb-4\">테트리스</h1>\r\n            <div className=\"mb-4\">\r\n                <p className=\"text-xl\">점수: {score}</p>\r\n            </div>\r\n            <canvas\r\n                ref={canvasRef}\r\n                width={BOARD_WIDTH * BLOCK_SIZE}\r\n                height={BOARD_HEIGHT * BLOCK_SIZE}\r\n                className=\"border-2 border-gray-600\"\r\n            />\r\n            {!isPlaying && (\r\n                <button\r\n                    onClick={startGame}\r\n                    className=\"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\"\r\n                >\r\n                    {gameOver ? '다시 시작' : '게임 시작'}\r\n                </button>\r\n            )}\r\n            {gameOver && (\r\n                <div className=\"mt-4 text-red-500 text-xl\">\r\n                    게임 오버!\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default TetrisGame;\r\n"],"mappings":";;AAAA;;AAEA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,MAAM,EAAEC,QAAQ,EAAEC,WAAW,QAAQ,OAAO;;AAEvE;AAAA,SAAAC,MAAA,IAAAC,OAAA;AAGA;AACA,MAAMC,MAAM,GAAG;EACXC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACjBC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACnBC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACzBC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3BC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EAC3BC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EACzBC,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;AAC5B,CAAC;;AAED;AACA,MAAMC,MAAM,GAAG;EACXP,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE,SAAS;EACZC,CAAC,EAAE;AACP,CAAC;;AAED;AACA,MAAME,WAAW,GAAG,EAAE;AACtB,MAAMC,YAAY,GAAG,EAAE;AACvB,MAAMC,UAAU,GAAG,EAAE;AAErB,MAAMC,UAAoB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC/B,MAAMC,SAAS,GAAGnB,MAAM,CAAoB,IAAI,CAAC;EACjD,MAAM,CAACoB,QAAQ,EAAEC,WAAW,CAAC,GAAGpB,QAAQ,CAAC,KAAK,CAAC;EAC/C,MAAM,CAACqB,KAAK,EAAEC,QAAQ,CAAC,GAAGtB,QAAQ,CAAC,CAAC,CAAC;EACrC,MAAM,CAACuB,SAAS,EAAEC,YAAY,CAAC,GAAGxB,QAAQ,CAAC,KAAK,CAAC;EACjD,MAAM,CAACyB,cAAc,EAAEC,iBAAiB,CAAC,GAAG1B,QAAQ,CAAwB,IAAI,CAAC;EAEjF,MAAM,CAAC2B,KAAK,EAAEC,QAAQ,CAAC,GAAG5B,QAAQ,CAC9B6B,KAAK,CAACf,YAAY,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAChB,WAAW,CAAC,CAACiB,IAAI,CAAC,CAAC,CAAC,CACvE,CAAC;EACD,MAAM,CAACE,YAAY,EAAEC,eAAe,CAAC,GAAGjC,QAAQ,CAItC,IAAI,CAAC;EAEf,MAAMkC,cAAc,GAAGjC,WAAW,CAAC,MAAM;IACrC,MAAMkC,KAAkB,GAAG,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC;IAC9D,MAAMC,IAAI,GAAGD,KAAK,CAACE,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,MAAM,CAAC,CAAC,GAAGJ,KAAK,CAACK,MAAM,CAAC,CAAC;IAC5D,MAAMC,KAAK,GAAGrC,MAAM,CAACgC,IAAI,CAAC;IAE1BH,eAAe,CAAC;MACZG,IAAI;MACJM,QAAQ,EAAE;QAAEC,CAAC,EAAEN,IAAI,CAACC,KAAK,CAACzB,WAAW,GAAG,CAAC,CAAC,GAAGwB,IAAI,CAACC,KAAK,CAACG,KAAK,CAAC,CAAC,CAAC,CAACD,MAAM,GAAG,CAAC,CAAC;QAAEI,CAAC,EAAE;MAAE,CAAC;MACpFH;IACJ,CAAC,CAAC;EACN,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMI,cAAc,GAAG5C,WAAW,CAAC,MAAM;IACrCmB,WAAW,CAAC,IAAI,CAAC;IACjBI,YAAY,CAAC,KAAK,CAAC;IACnBF,QAAQ,CAAC,CAAC,CAAC;EACf,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMwB,SAAS,GAAG7C,WAAW,CAAC,MAAM;IAChC2B,QAAQ,CAACC,KAAK,CAACf,YAAY,CAAC,CAACgB,IAAI,CAAC,IAAI,CAAC,CAACC,GAAG,CAAC,MAAMF,KAAK,CAAChB,WAAW,CAAC,CAACiB,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;IAC9ER,QAAQ,CAAC,CAAC,CAAC;IACXF,WAAW,CAAC,KAAK,CAAC;IAClBI,YAAY,CAAC,IAAI,CAAC;IAClBU,cAAc,CAAC,CAAC;EACpB,CAAC,EAAE,CAACA,cAAc,CAAC,CAAC;EAEpB,MAAMa,WAAW,GAAG9C,WAAW,CAAC,CAACyC,QAAkC,EAAED,KAAiB,KAAK;IACvF,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACD,MAAM,EAAEI,CAAC,EAAE,EAAE;MACnC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,CAAC,CAAC,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;QACtC,IAAIF,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,EAAE;UACb,MAAMK,MAAM,GAAGN,QAAQ,CAACC,CAAC,GAAGA,CAAC;UAC7B,MAAMM,MAAM,GAAGP,QAAQ,CAACE,CAAC,GAAGA,CAAC;UAE7B,IACII,MAAM,GAAG,CAAC,IACVA,MAAM,IAAInC,WAAW,IACrBoC,MAAM,IAAInC,YAAY,IACrBmC,MAAM,IAAI,CAAC,IAAItB,KAAK,CAACsB,MAAM,CAAC,CAACD,MAAM,CAAE,EACxC;YACE,OAAO,KAAK;UAChB;QACJ;MACJ;IACJ;IACA,OAAO,IAAI;EACf,CAAC,EAAE,CAACrB,KAAK,CAAC,CAAC;EAEX,MAAMuB,UAAU,GAAGjD,WAAW,CAAC,MAAM;IACjC,IAAI,CAAC+B,YAAY,EAAE;IAEnB,MAAMmB,QAAQ,GAAG,CAAC,GAAGxB,KAAK,CAAC;IAC3B,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,YAAY,CAACS,KAAK,CAACD,MAAM,EAAEI,CAAC,EAAE,EAAE;MAChD,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,YAAY,CAACS,KAAK,CAACG,CAAC,CAAC,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;QACnD,IAAIX,YAAY,CAACS,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,EAAE;UAC1B,MAAMM,MAAM,GAAGjB,YAAY,CAACU,QAAQ,CAACE,CAAC,GAAGA,CAAC;UAC1C,MAAMI,MAAM,GAAGhB,YAAY,CAACU,QAAQ,CAACC,CAAC,GAAGA,CAAC;UAE1C,IAAIM,MAAM,GAAG,CAAC,IAAKA,MAAM,GAAGnC,YAAY,IAAIqC,QAAQ,CAACF,MAAM,CAAC,CAACD,MAAM,CAAC,KAAK,CAAE,EAAE;YACzEH,cAAc,CAAC,CAAC;YAChB;UACJ;UAEA,IAAII,MAAM,GAAGnC,YAAY,EAAE;YACvBqC,QAAQ,CAACF,MAAM,CAAC,CAACD,MAAM,CAAC,GAAG,CAAC;UAChC;QACJ;MACJ;IACJ;IAEApB,QAAQ,CAACuB,QAAQ,CAAC;IAClBC,UAAU,CAACD,QAAQ,CAAC;IACpBjB,cAAc,CAAC,CAAC;EACpB,CAAC,EAAE,CAACF,YAAY,EAAEL,KAAK,EAAEO,cAAc,EAAEW,cAAc,CAAC,CAAC;EAEzD,MAAMQ,gBAAgB,GAAGpD,WAAW,CAAC,MAAM;IACvC,IAAI,CAAC+B,YAAY,EAAE,OAAO,KAAK;IAC/B,MAAMsB,YAAY,GAAG;MACjBX,CAAC,EAAEX,YAAY,CAACU,QAAQ,CAACC,CAAC;MAC1BC,CAAC,EAAEZ,YAAY,CAACU,QAAQ,CAACE,CAAC,GAAG;IACjC,CAAC;IACD,OAAO,CAACG,WAAW,CAACO,YAAY,EAAEtB,YAAY,CAACS,KAAK,CAAC;EACzD,CAAC,EAAE,CAACT,YAAY,EAAEe,WAAW,CAAC,CAAC;EAE/B,MAAMQ,SAAS,GAAGtD,WAAW,CAAC,CAACuD,EAAU,EAAEC,EAAU,KAAK;IACtD,IAAI,CAACzB,YAAY,IAAIb,QAAQ,EAAE;IAE/B,MAAMuC,WAAW,GAAG;MAChBf,CAAC,EAAEX,YAAY,CAACU,QAAQ,CAACC,CAAC,GAAGa,EAAE;MAC/BZ,CAAC,EAAEZ,YAAY,CAACU,QAAQ,CAACE,CAAC,GAAGa;IACjC,CAAC;IAED,IAAIV,WAAW,CAACW,WAAW,EAAE1B,YAAY,CAACS,KAAK,CAAC,EAAE;MAC9CR,eAAe,CAAC;QAAE,GAAGD,YAAY;QAAEU,QAAQ,EAAEgB;MAAY,CAAC,CAAC;MAE3D,IAAID,EAAE,KAAK,CAAC,IAAIJ,gBAAgB,CAAC,CAAC,EAAE;QAChC,IAAI,CAAC5B,cAAc,EAAE;UACjB,MAAMkC,KAAK,GAAGC,UAAU,CAAC,MAAM;YAC3BV,UAAU,CAAC,CAAC;YACZxB,iBAAiB,CAAC,IAAI,CAAC;UAC3B,CAAC,EAAE,GAAG,CAAC;UACPA,iBAAiB,CAACiC,KAAK,CAAC;QAC5B;MACJ,CAAC,MAAM,IAAIlC,cAAc,EAAE;QACvBoC,YAAY,CAACpC,cAAc,CAAC;QAC5BC,iBAAiB,CAAC,IAAI,CAAC;MAC3B;IACJ,CAAC,MAAM,IAAI+B,EAAE,GAAG,CAAC,EAAE;MACf,IAAI,CAAChC,cAAc,EAAE;QACjB,MAAMkC,KAAK,GAAGC,UAAU,CAAC,MAAM;UAC3BV,UAAU,CAAC,CAAC;UACZxB,iBAAiB,CAAC,IAAI,CAAC;QAC3B,CAAC,EAAE,GAAG,CAAC;QACPA,iBAAiB,CAACiC,KAAK,CAAC;MAC5B;IACJ;EACJ,CAAC,EAAE,CAAC3B,YAAY,EAAEb,QAAQ,EAAE4B,WAAW,EAAEG,UAAU,EAAEzB,cAAc,EAAE4B,gBAAgB,CAAC,CAAC;EAEvF,MAAMS,WAAW,GAAG7D,WAAW,CAAC,MAAM;IAClC,IAAI,CAAC+B,YAAY,IAAIb,QAAQ,EAAE;IAE/B,MAAM4C,OAAO,GAAG/B,YAAY,CAACS,KAAK,CAAC,CAAC,CAAC,CAACV,GAAG,CAAC,CAACiC,CAAC,EAAEC,CAAC,KAC3CjC,YAAY,CAACS,KAAK,CAACV,GAAG,CAACmC,GAAG,IAAIA,GAAG,CAACD,CAAC,CAAC,CAAC,CAACE,OAAO,CAAC,CAClD,CAAC;IAED,IAAIpB,WAAW,CAACf,YAAY,CAACU,QAAQ,EAAEqB,OAAO,CAAC,EAAE;MAC7C9B,eAAe,CAAC;QAAE,GAAGD,YAAY;QAAES,KAAK,EAAEsB;MAAQ,CAAC,CAAC;MAEpD,IAAIV,gBAAgB,CAAC,CAAC,EAAE;QACpB,IAAI,CAAC5B,cAAc,EAAE;UACjB,MAAMkC,KAAK,GAAGC,UAAU,CAAC,MAAM;YAC3BV,UAAU,CAAC,CAAC;YACZxB,iBAAiB,CAAC,IAAI,CAAC;UAC3B,CAAC,EAAE,GAAG,CAAC;UACPA,iBAAiB,CAACiC,KAAK,CAAC;QAC5B;MACJ,CAAC,MAAM,IAAIlC,cAAc,EAAE;QACvBoC,YAAY,CAACpC,cAAc,CAAC;QAC5BC,iBAAiB,CAAC,IAAI,CAAC;MAC3B;IACJ;EACJ,CAAC,EAAE,CAACM,YAAY,EAAEb,QAAQ,EAAE4B,WAAW,EAAEtB,cAAc,EAAE4B,gBAAgB,EAAEH,UAAU,CAAC,CAAC;EAEvF,MAAME,UAAU,GAAGnD,WAAW,CAAEkD,QAAoB,IAAK;IACrD,IAAIiB,YAAY,GAAG,CAAC;IAEpB,KAAK,IAAIxB,CAAC,GAAG9B,YAAY,GAAG,CAAC,EAAE8B,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MACxC,IAAIO,QAAQ,CAACP,CAAC,CAAC,CAACyB,KAAK,CAACC,IAAI,IAAIA,IAAI,KAAK,CAAC,CAAC,EAAE;QACvCnB,QAAQ,CAACoB,MAAM,CAAC3B,CAAC,EAAE,CAAC,CAAC;QACrBO,QAAQ,CAACqB,OAAO,CAAC3C,KAAK,CAAChB,WAAW,CAAC,CAACiB,IAAI,CAAC,CAAC,CAAC,CAAC;QAC5CsC,YAAY,EAAE;QACdxB,CAAC,EAAE;MACP;IACJ;IAEA,IAAIwB,YAAY,GAAG,CAAC,EAAE;MAClB9C,QAAQ,CAACmD,IAAI,IAAIA,IAAI,GAAGL,YAAY,GAAG,GAAG,CAAC;MAC3CxC,QAAQ,CAACuB,QAAQ,CAAC;IACtB;EACJ,CAAC,EAAE,EAAE,CAAC;EAEN,MAAMuB,QAAQ,GAAGzE,WAAW,CAAC,MAAM;IAC/B,IAAI,CAAC+B,YAAY,IAAIb,QAAQ,EAAE;IAE/B,IAAIwD,YAAY,GAAG,CAAC;IACpB,MAAMlC,KAAK,GAAGT,YAAY,CAACS,KAAK;IAChC,MAAMmC,aAAa,GAAG5C,YAAY,CAACU,QAAQ;IAE3C,OAAOK,WAAW,CAAC;MAAEJ,CAAC,EAAEiC,aAAa,CAACjC,CAAC;MAAEC,CAAC,EAAEgC,aAAa,CAAChC,CAAC,GAAG+B,YAAY,GAAG;IAAE,CAAC,EAAElC,KAAK,CAAC,EAAE;MACtFkC,YAAY,EAAE;IAClB;IAEA,MAAME,aAAa,GAAG;MAClBlC,CAAC,EAAEiC,aAAa,CAACjC,CAAC;MAClBC,CAAC,EAAEgC,aAAa,CAAChC,CAAC,GAAG+B;IACzB,CAAC;IAED,MAAMxB,QAAQ,GAAG,CAAC,GAAGxB,KAAK,CAAC;IAC3B,KAAK,IAAIiB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACD,MAAM,EAAEI,CAAC,EAAE,EAAE;MACnC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,KAAK,CAACG,CAAC,CAAC,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;QACtC,IAAIF,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,EAAE;UACb,MAAMK,MAAM,GAAG6B,aAAa,CAAClC,CAAC,GAAGA,CAAC;UAClC,MAAMM,MAAM,GAAG4B,aAAa,CAACjC,CAAC,GAAGA,CAAC;UAElC,IAAIK,MAAM,GAAG,CAAC,IAAKA,MAAM,GAAGnC,YAAY,IAAIqC,QAAQ,CAACF,MAAM,CAAC,CAACD,MAAM,CAAC,KAAK,CAAE,EAAE;YACzEH,cAAc,CAAC,CAAC;YAChB;UACJ;UAEA,IAAII,MAAM,GAAGnC,YAAY,EAAE;YACvBqC,QAAQ,CAACF,MAAM,CAAC,CAACD,MAAM,CAAC,GAAG,CAAC;UAChC;QACJ;MACJ;IACJ;IAEApB,QAAQ,CAACuB,QAAQ,CAAC;IAClBC,UAAU,CAACD,QAAQ,CAAC;IACpBjB,cAAc,CAAC,CAAC;EACpB,CAAC,EAAE,CAACF,YAAY,EAAEL,KAAK,EAAER,QAAQ,EAAE4B,WAAW,EAAEF,cAAc,EAAEO,UAAU,EAAElB,cAAc,CAAC,CAAC;EAE5FpC,SAAS,CAAC,MAAM;IACZ,IAAI,CAACyB,SAAS,EAAE;IAEhB,MAAMuD,YAAY,GAAGC,WAAW,CAAC,MAAM;MACnCxB,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;IACnB,CAAC,EAAE,IAAI,CAAC;IAER,OAAO,MAAMyB,aAAa,CAACF,YAAY,CAAC;EAC5C,CAAC,EAAE,CAACvD,SAAS,EAAEgC,SAAS,CAAC,CAAC;EAE1BzD,SAAS,CAAC,MAAM;IACZ,MAAMmF,cAAc,GAAIC,CAAgB,IAAK;MACzC,IAAI,CAAC3D,SAAS,EAAE;MAEhB,QAAQ2D,CAAC,CAACC,GAAG;QACT,KAAK,WAAW;UACZ5B,SAAS,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;UAChB;QACJ,KAAK,YAAY;UACbA,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;UACf;QACJ,KAAK,WAAW;UACZA,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC;UACf;QACJ,KAAK,SAAS;UACVO,WAAW,CAAC,CAAC;UACb;QACJ,KAAK,GAAG;UACJY,QAAQ,CAAC,CAAC;UACV;MACR;IACJ,CAAC;IAEDU,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEJ,cAAc,CAAC;IAClD,OAAO,MAAMG,MAAM,CAACE,mBAAmB,CAAC,SAAS,EAAEL,cAAc,CAAC;EACtE,CAAC,EAAE,CAAC1D,SAAS,EAAEgC,SAAS,EAAEO,WAAW,EAAEY,QAAQ,CAAC,CAAC;EAEjD5E,SAAS,CAAC,MAAM;IACZ,MAAMyF,MAAM,GAAGrE,SAAS,CAACsE,OAAO;IAChC,IAAI,CAACD,MAAM,EAAE;IAEb,MAAME,GAAG,GAAGF,MAAM,CAACG,UAAU,CAAC,IAAI,CAAC;IACnC,IAAI,CAACD,GAAG,EAAE;IAEVA,GAAG,CAACE,SAAS,CAAC,CAAC,EAAE,CAAC,EAAEJ,MAAM,CAACK,KAAK,EAAEL,MAAM,CAACM,MAAM,CAAC;IAEhD,KAAK,IAAIjD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,YAAY,EAAE8B,CAAC,EAAE,EAAE;MACnC,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,WAAW,EAAE8B,CAAC,EAAE,EAAE;QAClC,IAAIhB,KAAK,CAACiB,CAAC,CAAC,CAACD,CAAC,CAAC,EAAE;UACb8C,GAAG,CAACK,SAAS,GAAG,MAAM;UACtBL,GAAG,CAACM,QAAQ,CAACpD,CAAC,GAAG5B,UAAU,EAAE6B,CAAC,GAAG7B,UAAU,EAAEA,UAAU,GAAG,CAAC,EAAEA,UAAU,GAAG,CAAC,CAAC;QAChF;MACJ;IACJ;IAEA,IAAIiB,YAAY,EAAE;MACdyD,GAAG,CAACK,SAAS,GAAGlF,MAAM,CAACoB,YAAY,CAACI,IAAI,CAAC;MACzC,KAAK,IAAIQ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGZ,YAAY,CAACS,KAAK,CAACD,MAAM,EAAEI,CAAC,EAAE,EAAE;QAChD,KAAK,IAAID,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGX,YAAY,CAACS,KAAK,CAACG,CAAC,CAAC,CAACJ,MAAM,EAAEG,CAAC,EAAE,EAAE;UACnD,IAAIX,YAAY,CAACS,KAAK,CAACG,CAAC,CAAC,CAACD,CAAC,CAAC,EAAE;YAC1B8C,GAAG,CAACM,QAAQ,CACR,CAAC/D,YAAY,CAACU,QAAQ,CAACC,CAAC,GAAGA,CAAC,IAAI5B,UAAU,EAC1C,CAACiB,YAAY,CAACU,QAAQ,CAACE,CAAC,GAAGA,CAAC,IAAI7B,UAAU,EAC1CA,UAAU,GAAG,CAAC,EACdA,UAAU,GAAG,CACjB,CAAC;UACL;QACJ;MACJ;IACJ;EACJ,CAAC,EAAE,CAACY,KAAK,EAAEK,YAAY,CAAC,CAAC;EAEzB,oBACI7B,OAAA;IAAK6F,SAAS,EAAC,+EAA+E;IAAAC,QAAA,gBAC1F9F,OAAA;MAAI6F,SAAS,EAAC,yBAAyB;MAAAC,QAAA,EAAC;IAAI;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAI,CAAC,eACjDlG,OAAA;MAAK6F,SAAS,EAAC,MAAM;MAAAC,QAAA,eACjB9F,OAAA;QAAG6F,SAAS,EAAC,SAAS;QAAAC,QAAA,GAAC,gBAAI,EAAC5E,KAAK;MAAA;QAAA6E,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAAI;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACrC,CAAC,eACNlG,OAAA;MACImG,GAAG,EAAEpF,SAAU;MACf0E,KAAK,EAAE/E,WAAW,GAAGE,UAAW;MAChC8E,MAAM,EAAE/E,YAAY,GAAGC,UAAW;MAClCiF,SAAS,EAAC;IAA0B;MAAAE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACvC,CAAC,EACD,CAAC9E,SAAS,iBACPpB,OAAA;MACIoG,OAAO,EAAEzD,SAAU;MACnBkD,SAAS,EAAC,yDAAyD;MAAAC,QAAA,EAElE9E,QAAQ,GAAG,OAAO,GAAG;IAAO;MAAA+E,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACzB,CACX,EACAlF,QAAQ,iBACLhB,OAAA;MAAK6F,SAAS,EAAC,2BAA2B;MAAAC,QAAA,EAAC;IAE3C;MAAAC,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAK,CACR;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACA,CAAC;AAEd,CAAC;AAACpF,EAAA,CA3TID,UAAoB;AAAAwF,EAAA,GAApBxF,UAAoB;AA6T1B,eAAeA,UAAU;AAAC,IAAAwF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}