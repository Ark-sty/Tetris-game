{"ast":null,"code":"var _jsxFileName = \"D:\\\\MyGame\\\\src\\\\components\\\\TetrisGame.tsx\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\n\n// 테트리스 블록 타입 정의\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 블록 모양 정의\nconst BLOCKS = {\n  I: [[1, 1, 1, 1]],\n  O: [[1, 1], [1, 1]],\n  T: [[0, 1, 0], [1, 1, 1]],\n  L: [[1, 0], [1, 0], [1, 1]],\n  J: [[0, 1], [0, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0]],\n  Z: [[1, 1, 0], [0, 1, 1]]\n};\n\n// 블록 색상 정의\nconst COLORS = {\n  I: '#00f0f0',\n  O: '#f0f000',\n  T: '#a000f0',\n  L: '#f0a000',\n  J: '#0000f0',\n  S: '#00f000',\n  Z: '#f00000'\n};\n\n// 게임 보드 크기\nconst BOARD_WIDTH = 10;\nconst BOARD_HEIGHT = 20;\nconst BLOCK_SIZE = 30;\nconst TetrisGame = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [gameOver, setGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n\n  // 게임 상태\n  const [board, setBoard] = useState(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n  const [currentBlock, setCurrentBlock] = useState(null);\n\n  // 새로운 블록 생성\n  const createNewBlock = useCallback(() => {\n    const types = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\n    const type = types[Math.floor(Math.random() * types.length)];\n    const shape = BLOCKS[type];\n    setCurrentBlock({\n      type,\n      position: {\n        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),\n        y: 0\n      },\n      shape\n    });\n  }, []);\n\n  // 게임 오버 처리 함수 추가\n  const handleGameOver = useCallback(() => {\n    setGameOver(true);\n    setIsPlaying(false);\n    setScore(0);\n  }, []);\n\n  // 게임 시작\n  const startGame = useCallback(() => {\n    setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n    setScore(0);\n    setGameOver(false);\n    setIsPlaying(true);\n    createNewBlock();\n  }, [createNewBlock]);\n\n  // 이동 가능 여부 확인\n  const isValidMove = useCallback((position, shape) => {\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = position.x + x;\n          const boardY = position.y + y;\n          if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || boardY >= 0 && board[boardY][boardX]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }, [board]);\n\n  // 블록 배치\n  const placeBlock = useCallback(() => {\n    if (!currentBlock) return;\n    const newBoard = [...board];\n    for (let y = 0; y < currentBlock.shape.length; y++) {\n      for (let x = 0; x < currentBlock.shape[y].length; x++) {\n        if (currentBlock.shape[y][x]) {\n          const boardY = currentBlock.position.y + y;\n          const boardX = currentBlock.position.x + x;\n\n          // 게임 오버 조건: 블록이 화면 상단을 벗어나거나 다른 블록과 겹칠 때\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, createNewBlock, handleGameOver]);\n\n  // 블록 이동\n  const moveBlock = useCallback((dx, dy) => {\n    if (!currentBlock || gameOver) return;\n    const newPosition = {\n      x: currentBlock.position.x + dx,\n      y: currentBlock.position.y + dy\n    };\n\n    // 충돌 검사\n    if (isValidMove(newPosition, currentBlock.shape)) {\n      setCurrentBlock({\n        ...currentBlock,\n        position: newPosition\n      });\n    } else if (dy > 0) {\n      // 바닥에 닿았을 때\n      placeBlock();\n    }\n  }, [currentBlock, gameOver, isValidMove, placeBlock]);\n\n  // 블록 회전\n  const rotateBlock = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    const rotated = currentBlock.shape[0].map((_, i) => currentBlock.shape.map(row => row[i]).reverse());\n    if (isValidMove(currentBlock.position, rotated)) {\n      setCurrentBlock({\n        ...currentBlock,\n        shape: rotated\n      });\n    }\n  }, [currentBlock, gameOver, isValidMove]);\n\n  // 라인 체크 및 제거\n  const checkLines = useCallback(newBoard => {\n    let linesCleared = 0;\n    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\n      if (newBoard[y].every(cell => cell === 1)) {\n        newBoard.splice(y, 1);\n        newBoard.unshift(Array(BOARD_WIDTH).fill(0));\n        linesCleared++;\n        y++;\n      }\n    }\n    if (linesCleared > 0) {\n      setScore(prev => prev + linesCleared * 100);\n      setBoard(newBoard);\n    }\n  }, []);\n\n  // 하드 드롭 함수\n  const hardDrop = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    let dropDistance = 0;\n    const shape = currentBlock.shape;\n    const startPosition = currentBlock.position;\n\n    // 최대 이동 가능 거리 계산\n    while (isValidMove({\n      x: startPosition.x,\n      y: startPosition.y + dropDistance + 1\n    }, shape)) {\n      dropDistance++;\n    }\n\n    // 최종 위치\n    const finalPosition = {\n      x: startPosition.x,\n      y: startPosition.y + dropDistance\n    };\n\n    // 블록을 보드에 바로 고정\n    const newBoard = [...board];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = finalPosition.x + x;\n          const boardY = finalPosition.y + y;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\n\n  // 게임 루프\n  useEffect(() => {\n    if (!isPlaying) return;\n    const gameLoop = setInterval(() => {\n      moveBlock(0, 1);\n    }, 1000);\n    return () => clearInterval(gameLoop);\n  }, [isPlaying, moveBlock]);\n\n  // 키보드 이벤트 처리\n  useEffect(() => {\n    const handleKeyPress = e => {\n      if (!isPlaying) return;\n      switch (e.key) {\n        case 'ArrowLeft':\n          moveBlock(-1, 0);\n          break;\n        case 'ArrowRight':\n          moveBlock(1, 0);\n          break;\n        case 'ArrowDown':\n          moveBlock(0, 1);\n          break;\n        case 'ArrowUp':\n          rotateBlock();\n          break;\n        case ' ':\n          hardDrop();\n          break;\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\n\n  // 캔버스 렌더링\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n\n    // 캔버스 초기화\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // 보드 그리기\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        if (board[y][x]) {\n          ctx.fillStyle = '#666';\n          ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n        }\n      }\n    }\n\n    // 현재 블록 그리기\n    if (currentBlock) {\n      ctx.fillStyle = COLORS[currentBlock.type];\n      for (let y = 0; y < currentBlock.shape.length; y++) {\n        for (let x = 0; x < currentBlock.shape[y].length; x++) {\n          if (currentBlock.shape[y][x]) {\n            ctx.fillRect((currentBlock.position.x + x) * BLOCK_SIZE, (currentBlock.position.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n          }\n        }\n      }\n    }\n  }, [board, currentBlock]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"text-4xl font-bold mb-4\",\n      children: \"\\uD14C\\uD2B8\\uB9AC\\uC2A4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 311,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xl\",\n        children: [\"\\uC810\\uC218: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 313,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 312,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: BOARD_WIDTH * BLOCK_SIZE,\n      height: BOARD_HEIGHT * BLOCK_SIZE,\n      className: \"border-2 border-gray-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 315,\n      columnNumber: 13\n    }, this), !isPlaying && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startGame,\n      className: \"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\",\n      children: gameOver ? '다시 시작' : '게임 시작'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 17\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 text-red-500 text-xl\",\n      children: \"\\uAC8C\\uC784 \\uC624\\uBC84!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 330,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 310,\n    columnNumber: 9\n  }, this);\n};\n_s(TetrisGame, \"xFJXUgmodA6qRzJ/igg6NlZyT6s=\");\n_c = TetrisGame;\nexport default TetrisGame;\nvar _c;\n$RefreshReg$(_c, \"TetrisGame\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","BLOCKS","I","O","T","L","J","S","Z","COLORS","BOARD_WIDTH","BOARD_HEIGHT","BLOCK_SIZE","TetrisGame","_s","canvasRef","gameOver","setGameOver","score","setScore","isPlaying","setIsPlaying","board","setBoard","Array","fill","map","currentBlock","setCurrentBlock","createNewBlock","types","type","Math","floor","random","length","shape","position","x","y","handleGameOver","startGame","isValidMove","boardX","boardY","placeBlock","newBoard","checkLines","moveBlock","dx","dy","newPosition","rotateBlock","rotated","_","i","row","reverse","linesCleared","every","cell","splice","unshift","prev","hardDrop","dropDistance","startPosition","finalPosition","gameLoop","setInterval","clearInterval","handleKeyPress","e","key","window","addEventListener","removeEventListener","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","className","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","onClick","_c","$RefreshReg$"],"sources":["D:/MyGame/src/components/TetrisGame.tsx"],"sourcesContent":["import React, { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\n// 테트리스 블록 타입 정의\r\ntype BlockType = 'I' | 'O' | 'T' | 'L' | 'J' | 'S' | 'Z';\r\n\r\n// 블록 모양 정의\r\nconst BLOCKS = {\r\n    I: [[1, 1, 1, 1]],\r\n    O: [[1, 1], [1, 1]],\r\n    T: [[0, 1, 0], [1, 1, 1]],\r\n    L: [[1, 0], [1, 0], [1, 1]],\r\n    J: [[0, 1], [0, 1], [1, 1]],\r\n    S: [[0, 1, 1], [1, 1, 0]],\r\n    Z: [[1, 1, 0], [0, 1, 1]]\r\n};\r\n\r\n// 블록 색상 정의\r\nconst COLORS = {\r\n    I: '#00f0f0',\r\n    O: '#f0f000',\r\n    T: '#a000f0',\r\n    L: '#f0a000',\r\n    J: '#0000f0',\r\n    S: '#00f000',\r\n    Z: '#f00000'\r\n};\r\n\r\n// 게임 보드 크기\r\nconst BOARD_WIDTH = 10;\r\nconst BOARD_HEIGHT = 20;\r\nconst BLOCK_SIZE = 30;\r\n\r\nconst TetrisGame: React.FC = () => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [score, setScore] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n\r\n    // 게임 상태\r\n    const [board, setBoard] = useState<number[][]>(\r\n        Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0))\r\n    );\r\n    const [currentBlock, setCurrentBlock] = useState<{\r\n        type: BlockType;\r\n        position: { x: number; y: number };\r\n        shape: number[][];\r\n    } | null>(null);\r\n\r\n    // 새로운 블록 생성\r\n    const createNewBlock = useCallback(() => {\r\n        const types: BlockType[] = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\r\n        const type = types[Math.floor(Math.random() * types.length)];\r\n        const shape = BLOCKS[type];\r\n\r\n        setCurrentBlock({\r\n            type,\r\n            position: { x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2), y: 0 },\r\n            shape\r\n        });\r\n    }, []);\r\n\r\n    // 게임 오버 처리 함수 추가\r\n    const handleGameOver = useCallback(() => {\r\n        setGameOver(true);\r\n        setIsPlaying(false);\r\n        setScore(0);\r\n    }, []);\r\n\r\n    // 게임 시작\r\n    const startGame = useCallback(() => {\r\n        setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\r\n        setScore(0);\r\n        setGameOver(false);\r\n        setIsPlaying(true);\r\n        createNewBlock();\r\n    }, [createNewBlock]);\r\n\r\n    // 이동 가능 여부 확인\r\n    const isValidMove = useCallback((position: { x: number; y: number }, shape: number[][]) => {\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = position.x + x;\r\n                    const boardY = position.y + y;\r\n\r\n                    if (\r\n                        boardX < 0 ||\r\n                        boardX >= BOARD_WIDTH ||\r\n                        boardY >= BOARD_HEIGHT ||\r\n                        (boardY >= 0 && board[boardY][boardX])\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }, [board]);\r\n\r\n    // 블록 배치\r\n    const placeBlock = useCallback(() => {\r\n        if (!currentBlock) return;\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < currentBlock.shape.length; y++) {\r\n            for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                if (currentBlock.shape[y][x]) {\r\n                    const boardY = currentBlock.position.y + y;\r\n                    const boardX = currentBlock.position.x + x;\r\n\r\n                    // 게임 오버 조건: 블록이 화면 상단을 벗어나거나 다른 블록과 겹칠 때\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, createNewBlock, handleGameOver]);\r\n\r\n    // 블록 이동\r\n    const moveBlock = useCallback((dx: number, dy: number) => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const newPosition = {\r\n            x: currentBlock.position.x + dx,\r\n            y: currentBlock.position.y + dy\r\n        };\r\n\r\n        // 충돌 검사\r\n        if (isValidMove(newPosition, currentBlock.shape)) {\r\n            setCurrentBlock({\r\n                ...currentBlock,\r\n                position: newPosition\r\n            });\r\n        } else if (dy > 0) {\r\n            // 바닥에 닿았을 때\r\n            placeBlock();\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, placeBlock]);\r\n\r\n    // 블록 회전\r\n    const rotateBlock = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const rotated = currentBlock.shape[0].map((_, i) =>\r\n            currentBlock.shape.map(row => row[i]).reverse()\r\n        );\r\n\r\n        if (isValidMove(currentBlock.position, rotated)) {\r\n            setCurrentBlock({\r\n                ...currentBlock,\r\n                shape: rotated\r\n            });\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove]);\r\n\r\n    // 라인 체크 및 제거\r\n    const checkLines = useCallback((newBoard: number[][]) => {\r\n        let linesCleared = 0;\r\n\r\n        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\r\n            if (newBoard[y].every(cell => cell === 1)) {\r\n                newBoard.splice(y, 1);\r\n                newBoard.unshift(Array(BOARD_WIDTH).fill(0));\r\n                linesCleared++;\r\n                y++;\r\n            }\r\n        }\r\n\r\n        if (linesCleared > 0) {\r\n            setScore(prev => prev + linesCleared * 100);\r\n            setBoard(newBoard);\r\n        }\r\n    }, []);\r\n\r\n    // 하드 드롭 함수\r\n    const hardDrop = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        let dropDistance = 0;\r\n        const shape = currentBlock.shape;\r\n        const startPosition = currentBlock.position;\r\n\r\n        // 최대 이동 가능 거리 계산\r\n        while (\r\n            isValidMove({ x: startPosition.x, y: startPosition.y + dropDistance + 1 }, shape)\r\n        ) {\r\n            dropDistance++;\r\n        }\r\n\r\n        // 최종 위치\r\n        const finalPosition = {\r\n            x: startPosition.x,\r\n            y: startPosition.y + dropDistance\r\n        };\r\n\r\n        // 블록을 보드에 바로 고정\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = finalPosition.x + x;\r\n                    const boardY = finalPosition.y + y;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\r\n\r\n    // 게임 루프\r\n    useEffect(() => {\r\n        if (!isPlaying) return;\r\n\r\n        const gameLoop = setInterval(() => {\r\n            moveBlock(0, 1);\r\n        }, 1000);\r\n\r\n        return () => clearInterval(gameLoop);\r\n    }, [isPlaying, moveBlock]);\r\n\r\n    // 키보드 이벤트 처리\r\n    useEffect(() => {\r\n        const handleKeyPress = (e: KeyboardEvent) => {\r\n            if (!isPlaying) return;\r\n\r\n            switch (e.key) {\r\n                case 'ArrowLeft':\r\n                    moveBlock(-1, 0);\r\n                    break;\r\n                case 'ArrowRight':\r\n                    moveBlock(1, 0);\r\n                    break;\r\n                case 'ArrowDown':\r\n                    moveBlock(0, 1);\r\n                    break;\r\n                case 'ArrowUp':\r\n                    rotateBlock();\r\n                    break;\r\n                case ' ':\r\n                    hardDrop();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyPress);\r\n        return () => window.removeEventListener('keydown', handleKeyPress);\r\n    }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\r\n\r\n    // 캔버스 렌더링\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        // 캔버스 초기화\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // 보드 그리기\r\n        for (let y = 0; y < BOARD_HEIGHT; y++) {\r\n            for (let x = 0; x < BOARD_WIDTH; x++) {\r\n                if (board[y][x]) {\r\n                    ctx.fillStyle = '#666';\r\n                    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        // 현재 블록 그리기\r\n        if (currentBlock) {\r\n            ctx.fillStyle = COLORS[currentBlock.type];\r\n            for (let y = 0; y < currentBlock.shape.length; y++) {\r\n                for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                    if (currentBlock.shape[y][x]) {\r\n                        ctx.fillRect(\r\n                            (currentBlock.position.x + x) * BLOCK_SIZE,\r\n                            (currentBlock.position.y + y) * BLOCK_SIZE,\r\n                            BLOCK_SIZE - 1,\r\n                            BLOCK_SIZE - 1\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [board, currentBlock]);\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\">\r\n            <h1 className=\"text-4xl font-bold mb-4\">테트리스</h1>\r\n            <div className=\"mb-4\">\r\n                <p className=\"text-xl\">점수: {score}</p>\r\n            </div>\r\n            <canvas\r\n                ref={canvasRef}\r\n                width={BOARD_WIDTH * BLOCK_SIZE}\r\n                height={BOARD_HEIGHT * BLOCK_SIZE}\r\n                className=\"border-2 border-gray-600\"\r\n            />\r\n            {!isPlaying && (\r\n                <button\r\n                    onClick={startGame}\r\n                    className=\"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\"\r\n                >\r\n                    {gameOver ? '다시 시작' : '게임 시작'}\r\n                </button>\r\n            )}\r\n            {gameOver && (\r\n                <div className=\"mt-4 text-red-500 text-xl\">\r\n                    게임 오버!\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default TetrisGame; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}