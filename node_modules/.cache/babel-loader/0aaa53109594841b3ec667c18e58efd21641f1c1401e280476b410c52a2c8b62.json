{"ast":null,"code":"var _jsxFileName = \"D:\\\\MyGame\\\\src\\\\components\\\\TetrisGame.tsx\",\n  _s = $RefreshSig$();\n// (생략된 import 및 기본 설정은 유지)\n\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\n\n// 테트리스 블록 타입 정의\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 블록 모양 정의\nconst BLOCKS = {\n  I: [[1, 1, 1, 1]],\n  O: [[1, 1], [1, 1]],\n  T: [[0, 1, 0], [1, 1, 1]],\n  L: [[1, 0], [1, 0], [1, 1]],\n  J: [[0, 1], [0, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0]],\n  Z: [[1, 1, 0], [0, 1, 1]]\n};\n\n// 블록 색상 정의\nconst COLORS = {\n  I: '#00f0f0',\n  O: '#f0f000',\n  T: '#a000f0',\n  L: '#f0a000',\n  J: '#0000f0',\n  S: '#00f000',\n  Z: '#f00000'\n};\n\n// 게임 보드 크기\nconst BOARD_WIDTH = 10;\nconst BOARD_HEIGHT = 20;\nconst BLOCK_SIZE = 30;\nconst TetrisGame = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [gameOver, setGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [level, setLevel] = useState(0);\n  const [linesClearedTotal, setLinesClearedTotal] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [lockDelayTimer, setLockDelayTimer] = useState(null);\n  const [dropInterval, setDropInterval] = useState(null);\n  const [lastDropTime, setLastDropTime] = useState(Date.now());\n  const [nextBlockType, setNextBlockType] = useState(null);\n  const [board, setBoard] = useState(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n  const [currentBlock, setCurrentBlock] = useState(null);\n  const createNewBlock = useCallback(() => {\n    const types = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\n    const nextType = nextBlockType || types[Math.floor(Math.random() * types.length)];\n    const shape = BLOCKS[nextType];\n    setCurrentBlock({\n      type: nextType,\n      position: {\n        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),\n        y: 0\n      },\n      shape\n    });\n    const newType = types[Math.floor(Math.random() * types.length)];\n    setNextBlockType(newType);\n  }, [nextBlockType]);\n  const handleGameOver = useCallback(() => {\n    setGameOver(true);\n    setIsPlaying(false);\n\n    // 게임 오버 시 점수 저장\n    const playerName = prompt('플레이어 이름을 입력해주세요:') || 'Anonymous';\n    const newScore = {\n      id: Date.now(),\n      playerName,\n      score,\n      level,\n      date: new Date().toISOString()\n    };\n    const savedScores = localStorage.getItem('tetrisScores');\n    const scores = savedScores ? JSON.parse(savedScores) : [];\n    scores.push(newScore);\n    localStorage.setItem('tetrisScores', JSON.stringify(scores));\n    setScore(0);\n  }, [score, level]);\n  const startGame = useCallback(() => {\n    setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n    setScore(0);\n    setLevel(0);\n    setLinesClearedTotal(0);\n    setGameOver(false);\n    setIsPlaying(true);\n    setLastDropTime(Date.now());\n    const types = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\n    setNextBlockType(types[Math.floor(Math.random() * types.length)]);\n    createNewBlock();\n  }, [createNewBlock]);\n  const isValidMove = useCallback((position, shape) => {\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = position.x + x;\n          const boardY = position.y + y;\n          if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || boardY >= 0 && board[boardY][boardX]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }, [board]);\n  const placeBlock = useCallback(() => {\n    if (!currentBlock) return;\n    const newBoard = [...board];\n    for (let y = 0; y < currentBlock.shape.length; y++) {\n      for (let x = 0; x < currentBlock.shape[y].length; x++) {\n        if (currentBlock.shape[y][x]) {\n          const boardY = currentBlock.position.y + y;\n          const boardX = currentBlock.position.x + x;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, createNewBlock, handleGameOver]);\n  const isTouchingGround = useCallback(() => {\n    if (!currentBlock) return false;\n    const testPosition = {\n      x: currentBlock.position.x,\n      y: currentBlock.position.y + 1\n    };\n    return !isValidMove(testPosition, currentBlock.shape);\n  }, [currentBlock, isValidMove]);\n  const moveBlock = useCallback((dx, dy) => {\n    if (!currentBlock || gameOver) return;\n    const newPosition = {\n      x: currentBlock.position.x + dx,\n      y: currentBlock.position.y + dy\n    };\n    if (isValidMove(newPosition, currentBlock.shape)) {\n      setCurrentBlock({\n        ...currentBlock,\n        position: newPosition\n      });\n      if (dy !== 0 && isTouchingGround()) {\n        // 이미 lockDelayTimer가 있으면 새로 만들지 않는다!\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (!isTouchingGround() && lockDelayTimer) {\n        // 바닥에서 떨어지면 타이머 취소\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    } else if (dy > 0) {\n      if (!lockDelayTimer) {\n        const timer = setTimeout(() => {\n          placeBlock();\n          setLockDelayTimer(null);\n        }, 500);\n        setLockDelayTimer(timer);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\n\n  // 점수 계산 함수 (NES 스타일)\n  const calculateScore = (lines, level) => {\n    switch (lines) {\n      case 1:\n        return 40 * (level + 1);\n      case 2:\n        return 100 * (level + 1);\n      case 3:\n        return 300 * (level + 1);\n      case 4:\n        return 1200 * (level + 1);\n      default:\n        return 0;\n    }\n  };\n\n  // SRS 회전을 위한 벽킥 시도\n  const tryWallKick = (position, rotated) => {\n    const offsets = [0, -1, 1, -2, 2];\n    for (const dx of offsets) {\n      const testPos = {\n        x: position.x + dx,\n        y: position.y\n      };\n      if (isValidMove(testPos, rotated)) return testPos;\n    }\n    return null;\n  };\n\n  // 회전 함수 수정 (SRS 적용)\n  const rotateBlock = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    const rotated = currentBlock.shape[0].map((_, i) => currentBlock.shape.map(row => row[i]).reverse());\n    const kicked = tryWallKick(currentBlock.position, rotated);\n    if (kicked) {\n      setCurrentBlock({\n        ...currentBlock,\n        shape: rotated,\n        position: kicked\n      });\n      if (isTouchingGround()) {\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (!isTouchingGround() && lockDelayTimer) {\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\n\n  // checkLines 함수 수정 (점수 및 레벨)\n  const checkLines = useCallback(newBoard => {\n    let linesCleared = 0;\n    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\n      if (newBoard[y].every(cell => cell === 1)) {\n        newBoard.splice(y, 1);\n        newBoard.unshift(Array(BOARD_WIDTH).fill(0));\n        linesCleared++;\n        y++;\n      }\n    }\n    if (linesCleared > 0) {\n      setScore(prev => prev + calculateScore(linesCleared, level));\n      setLinesClearedTotal(prev => {\n        const total = prev + linesCleared;\n        setLevel(Math.floor(total / 10));\n        return total;\n      });\n      setBoard(newBoard);\n    }\n  }, [level]);\n  const hardDrop = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    let dropDistance = 0;\n    const shape = currentBlock.shape;\n    const startPosition = currentBlock.position;\n    while (isValidMove({\n      x: startPosition.x,\n      y: startPosition.y + dropDistance + 1\n    }, shape)) {\n      dropDistance++;\n    }\n    const finalPosition = {\n      x: startPosition.x,\n      y: startPosition.y + dropDistance\n    };\n    const newBoard = [...board];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = finalPosition.x + x;\n          const boardY = finalPosition.y + y;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\n\n  // 게임 루프 수정 (레벨 기반 속도)\n  const gameLoop = useCallback(() => {\n    if (!isPlaying) return;\n    const now = Date.now();\n    const speed = Math.max(1000 - level * 100, 100); // 최소 속도 제한\n    if (now - lastDropTime >= speed) {\n      moveBlock(0, 1);\n      setLastDropTime(now);\n    }\n  }, [isPlaying, moveBlock, lastDropTime, level]);\n  useEffect(() => {\n    if (!isPlaying) {\n      if (dropInterval) {\n        clearInterval(dropInterval);\n        setDropInterval(null);\n      }\n      return;\n    }\n    const interval = setInterval(gameLoop, 16); // 약 60fps\n    setDropInterval(interval);\n    return () => {\n      clearInterval(interval);\n      setDropInterval(null);\n    };\n  }, [isPlaying, gameLoop]);\n  useEffect(() => {\n    const handleKeyPress = e => {\n      if (!isPlaying) return;\n      switch (e.key) {\n        case 'ArrowLeft':\n          moveBlock(-1, 0);\n          break;\n        case 'ArrowRight':\n          moveBlock(1, 0);\n          break;\n        case 'ArrowDown':\n          moveBlock(0, 1);\n          break;\n        case 'ArrowUp':\n          rotateBlock();\n          break;\n        case ' ':\n          hardDrop();\n          break;\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\n\n  // 고스트 블록 위치 계산 함수 추가\n  const getGhostPosition = useCallback(() => {\n    if (!currentBlock) return null;\n    let dropY = currentBlock.position.y;\n    while (isValidMove({\n      x: currentBlock.position.x,\n      y: dropY + 1\n    }, currentBlock.shape)) {\n      dropY++;\n    }\n    return {\n      x: currentBlock.position.x,\n      y: dropY\n    };\n  }, [currentBlock, isValidMove]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n    // 보드 그리기\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        if (board[y][x]) {\n          ctx.fillStyle = '#666';\n          ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n        }\n      }\n    }\n    if (currentBlock) {\n      // 고스트 블럭 먼저 그리기 (반투명)\n      const ghostPos = getGhostPosition();\n      if (ghostPos) {\n        ctx.fillStyle = COLORS[currentBlock.type] + '80'; // 50% 투명도\n        for (let y = 0; y < currentBlock.shape.length; y++) {\n          for (let x = 0; x < currentBlock.shape[y].length; x++) {\n            if (currentBlock.shape[y][x]) {\n              ctx.fillRect((ghostPos.x + x) * BLOCK_SIZE, (ghostPos.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n            }\n          }\n        }\n      }\n\n      // 실제 블럭 그리기\n      ctx.fillStyle = COLORS[currentBlock.type];\n      for (let y = 0; y < currentBlock.shape.length; y++) {\n        for (let x = 0; x < currentBlock.shape[y].length; x++) {\n          if (currentBlock.shape[y][x]) {\n            ctx.fillRect((currentBlock.position.x + x) * BLOCK_SIZE, (currentBlock.position.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n          }\n        }\n      }\n    }\n  }, [board, currentBlock, getGhostPosition]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"text-4xl font-bold mb-4\",\n      children: \"\\uD14C\\uD2B8\\uB9AC\\uC2A4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 438,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4\",\n      children: [/*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xl\",\n        children: [\"\\uC810\\uC218: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 440,\n        columnNumber: 17\n      }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-sm text-gray-300\",\n        children: [\"\\uB808\\uBCA8: \", level]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 441,\n        columnNumber: 17\n      }, this), nextBlockType && /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mt-2 text-sm text-gray-300\",\n        children: [/*#__PURE__*/_jsxDEV(\"p\", {\n          children: \"\\uB2E4\\uC74C \\uBE14\\uB7ED:\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 444,\n          columnNumber: 25\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"inline-block p-2 border border-gray-400\",\n          children: BLOCKS[nextBlockType].map((row, y) => /*#__PURE__*/_jsxDEV(\"div\", {\n            className: \"flex\",\n            children: row.map((cell, x) => /*#__PURE__*/_jsxDEV(\"div\", {\n              style: {\n                width: 12,\n                height: 12,\n                backgroundColor: cell ? COLORS[nextBlockType] : 'transparent',\n                border: cell ? '1px solid #444' : '1px solid transparent'\n              }\n            }, x, false, {\n              fileName: _jsxFileName,\n              lineNumber: 449,\n              columnNumber: 41\n            }, this))\n          }, y, false, {\n            fileName: _jsxFileName,\n            lineNumber: 447,\n            columnNumber: 33\n          }, this))\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 445,\n          columnNumber: 25\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 443,\n        columnNumber: 21\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 439,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: BOARD_WIDTH * BLOCK_SIZE,\n      height: BOARD_HEIGHT * BLOCK_SIZE,\n      className: \"border-2 border-gray-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 465,\n      columnNumber: 13\n    }, this), !isPlaying && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startGame,\n      className: \"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\",\n      children: gameOver ? '다시 시작' : '게임 시작'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 472,\n      columnNumber: 17\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 text-red-500 text-xl\",\n      children: \"\\uAC8C\\uC784 \\uC624\\uBC84!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 480,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 437,\n    columnNumber: 9\n  }, this);\n};\n_s(TetrisGame, \"FoCSDvC/3n/S687kHgfXgphkBbA=\");\n_c = TetrisGame;\nexport default TetrisGame;\nvar _c;\n$RefreshReg$(_c, \"TetrisGame\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","BLOCKS","I","O","T","L","J","S","Z","COLORS","BOARD_WIDTH","BOARD_HEIGHT","BLOCK_SIZE","TetrisGame","_s","canvasRef","gameOver","setGameOver","score","setScore","level","setLevel","linesClearedTotal","setLinesClearedTotal","isPlaying","setIsPlaying","lockDelayTimer","setLockDelayTimer","dropInterval","setDropInterval","lastDropTime","setLastDropTime","Date","now","nextBlockType","setNextBlockType","board","setBoard","Array","fill","map","currentBlock","setCurrentBlock","createNewBlock","types","nextType","Math","floor","random","length","shape","type","position","x","y","newType","handleGameOver","playerName","prompt","newScore","id","date","toISOString","savedScores","localStorage","getItem","scores","JSON","parse","push","setItem","stringify","startGame","isValidMove","boardX","boardY","placeBlock","newBoard","checkLines","isTouchingGround","testPosition","moveBlock","dx","dy","newPosition","timer","setTimeout","clearTimeout","calculateScore","lines","tryWallKick","rotated","offsets","testPos","rotateBlock","_","i","row","reverse","kicked","linesCleared","every","cell","splice","unshift","prev","total","hardDrop","dropDistance","startPosition","finalPosition","gameLoop","speed","max","clearInterval","interval","setInterval","handleKeyPress","e","key","window","addEventListener","removeEventListener","getGhostPosition","dropY","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","ghostPos","className","children","fileName","_jsxFileName","lineNumber","columnNumber","style","backgroundColor","border","ref","onClick","_c","$RefreshReg$"],"sources":["D:/MyGame/src/components/TetrisGame.tsx"],"sourcesContent":["// (생략된 import 및 기본 설정은 유지)\r\n\r\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\n// 테트리스 블록 타입 정의\r\ntype BlockType = 'I' | 'O' | 'T' | 'L' | 'J' | 'S' | 'Z';\r\n\r\n// 블록 모양 정의\r\nconst BLOCKS = {\r\n    I: [[1, 1, 1, 1]],\r\n    O: [[1, 1], [1, 1]],\r\n    T: [[0, 1, 0], [1, 1, 1]],\r\n    L: [[1, 0], [1, 0], [1, 1]],\r\n    J: [[0, 1], [0, 1], [1, 1]],\r\n    S: [[0, 1, 1], [1, 1, 0]],\r\n    Z: [[1, 1, 0], [0, 1, 1]]\r\n};\r\n\r\n// 블록 색상 정의\r\nconst COLORS = {\r\n    I: '#00f0f0',\r\n    O: '#f0f000',\r\n    T: '#a000f0',\r\n    L: '#f0a000',\r\n    J: '#0000f0',\r\n    S: '#00f000',\r\n    Z: '#f00000'\r\n};\r\n\r\n// 게임 보드 크기\r\nconst BOARD_WIDTH = 10;\r\nconst BOARD_HEIGHT = 20;\r\nconst BLOCK_SIZE = 30;\r\n\r\nconst TetrisGame: React.FC = () => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [score, setScore] = useState(0);\r\n    const [level, setLevel] = useState(0);\r\n    const [linesClearedTotal, setLinesClearedTotal] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [lockDelayTimer, setLockDelayTimer] = useState<NodeJS.Timeout | null>(null);\r\n    const [dropInterval, setDropInterval] = useState<NodeJS.Timeout | null>(null);\r\n    const [lastDropTime, setLastDropTime] = useState<number>(Date.now());\r\n    const [nextBlockType, setNextBlockType] = useState<BlockType | null>(null);\r\n\r\n    const [board, setBoard] = useState<number[][]>(\r\n        Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0))\r\n    );\r\n    const [currentBlock, setCurrentBlock] = useState<{\r\n        type: BlockType;\r\n        position: { x: number; y: number };\r\n        shape: number[][];\r\n    } | null>(null);\r\n\r\n    const createNewBlock = useCallback(() => {\r\n        const types: BlockType[] = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\r\n        const nextType = nextBlockType || types[Math.floor(Math.random() * types.length)];\r\n        const shape = BLOCKS[nextType];\r\n\r\n        setCurrentBlock({\r\n            type: nextType,\r\n            position: { x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2), y: 0 },\r\n            shape\r\n        });\r\n\r\n        const newType = types[Math.floor(Math.random() * types.length)];\r\n        setNextBlockType(newType);\r\n    }, [nextBlockType]);\r\n\r\n    const handleGameOver = useCallback(() => {\r\n        setGameOver(true);\r\n        setIsPlaying(false);\r\n\r\n        // 게임 오버 시 점수 저장\r\n        const playerName = prompt('플레이어 이름을 입력해주세요:') || 'Anonymous';\r\n        const newScore = {\r\n            id: Date.now(),\r\n            playerName,\r\n            score,\r\n            level,\r\n            date: new Date().toISOString()\r\n        };\r\n\r\n        const savedScores = localStorage.getItem('tetrisScores');\r\n        const scores = savedScores ? JSON.parse(savedScores) : [];\r\n        scores.push(newScore);\r\n        localStorage.setItem('tetrisScores', JSON.stringify(scores));\r\n\r\n        setScore(0);\r\n    }, [score, level]);\r\n\r\n    const startGame = useCallback(() => {\r\n        setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\r\n        setScore(0);\r\n        setLevel(0);\r\n        setLinesClearedTotal(0);\r\n        setGameOver(false);\r\n        setIsPlaying(true);\r\n        setLastDropTime(Date.now());\r\n\r\n        const types: BlockType[] = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\r\n        setNextBlockType(types[Math.floor(Math.random() * types.length)]);\r\n        createNewBlock();\r\n    }, [createNewBlock]);\r\n\r\n    const isValidMove = useCallback((position: { x: number; y: number }, shape: number[][]) => {\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = position.x + x;\r\n                    const boardY = position.y + y;\r\n\r\n                    if (\r\n                        boardX < 0 ||\r\n                        boardX >= BOARD_WIDTH ||\r\n                        boardY >= BOARD_HEIGHT ||\r\n                        (boardY >= 0 && board[boardY][boardX])\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }, [board]);\r\n\r\n    const placeBlock = useCallback(() => {\r\n        if (!currentBlock) return;\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < currentBlock.shape.length; y++) {\r\n            for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                if (currentBlock.shape[y][x]) {\r\n                    const boardY = currentBlock.position.y + y;\r\n                    const boardX = currentBlock.position.x + x;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, createNewBlock, handleGameOver]);\r\n\r\n    const isTouchingGround = useCallback(() => {\r\n        if (!currentBlock) return false;\r\n        const testPosition = {\r\n            x: currentBlock.position.x,\r\n            y: currentBlock.position.y + 1\r\n        };\r\n        return !isValidMove(testPosition, currentBlock.shape);\r\n    }, [currentBlock, isValidMove]);\r\n\r\n    const moveBlock = useCallback((dx: number, dy: number) => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const newPosition = {\r\n            x: currentBlock.position.x + dx,\r\n            y: currentBlock.position.y + dy\r\n        };\r\n\r\n        if (isValidMove(newPosition, currentBlock.shape)) {\r\n            setCurrentBlock({ ...currentBlock, position: newPosition });\r\n\r\n            if (dy !== 0 && isTouchingGround()) {\r\n                // 이미 lockDelayTimer가 있으면 새로 만들지 않는다!\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (!isTouchingGround() && lockDelayTimer) {\r\n                // 바닥에서 떨어지면 타이머 취소\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        } else if (dy > 0) {\r\n            if (!lockDelayTimer) {\r\n                const timer = setTimeout(() => {\r\n                    placeBlock();\r\n                    setLockDelayTimer(null);\r\n                }, 500);\r\n                setLockDelayTimer(timer);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\r\n\r\n    // 점수 계산 함수 (NES 스타일)\r\n    const calculateScore = (lines: number, level: number): number => {\r\n        switch (lines) {\r\n            case 1: return 40 * (level + 1);\r\n            case 2: return 100 * (level + 1);\r\n            case 3: return 300 * (level + 1);\r\n            case 4: return 1200 * (level + 1);\r\n            default: return 0;\r\n        }\r\n    };\r\n\r\n    // SRS 회전을 위한 벽킥 시도\r\n    const tryWallKick = (position: { x: number; y: number }, rotated: number[][]): { x: number; y: number } | null => {\r\n        const offsets = [0, -1, 1, -2, 2];\r\n        for (const dx of offsets) {\r\n            const testPos = { x: position.x + dx, y: position.y };\r\n            if (isValidMove(testPos, rotated)) return testPos;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    // 회전 함수 수정 (SRS 적용)\r\n    const rotateBlock = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const rotated = currentBlock.shape[0].map((_, i) =>\r\n            currentBlock.shape.map(row => row[i]).reverse()\r\n        );\r\n\r\n        const kicked = tryWallKick(currentBlock.position, rotated);\r\n        if (kicked) {\r\n            setCurrentBlock({ ...currentBlock, shape: rotated, position: kicked });\r\n\r\n            if (isTouchingGround()) {\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (!isTouchingGround() && lockDelayTimer) {\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\r\n\r\n    // checkLines 함수 수정 (점수 및 레벨)\r\n    const checkLines = useCallback((newBoard: number[][]) => {\r\n        let linesCleared = 0;\r\n\r\n        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\r\n            if (newBoard[y].every(cell => cell === 1)) {\r\n                newBoard.splice(y, 1);\r\n                newBoard.unshift(Array(BOARD_WIDTH).fill(0));\r\n                linesCleared++;\r\n                y++;\r\n            }\r\n        }\r\n\r\n        if (linesCleared > 0) {\r\n            setScore(prev => prev + calculateScore(linesCleared, level));\r\n            setLinesClearedTotal(prev => {\r\n                const total = prev + linesCleared;\r\n                setLevel(Math.floor(total / 10));\r\n                return total;\r\n            });\r\n            setBoard(newBoard);\r\n        }\r\n    }, [level]);\r\n\r\n    const hardDrop = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        let dropDistance = 0;\r\n        const shape = currentBlock.shape;\r\n        const startPosition = currentBlock.position;\r\n\r\n        while (isValidMove({ x: startPosition.x, y: startPosition.y + dropDistance + 1 }, shape)) {\r\n            dropDistance++;\r\n        }\r\n\r\n        const finalPosition = {\r\n            x: startPosition.x,\r\n            y: startPosition.y + dropDistance\r\n        };\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = finalPosition.x + x;\r\n                    const boardY = finalPosition.y + y;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\r\n\r\n    // 게임 루프 수정 (레벨 기반 속도)\r\n    const gameLoop = useCallback(() => {\r\n        if (!isPlaying) return;\r\n\r\n        const now = Date.now();\r\n        const speed = Math.max(1000 - level * 100, 100); // 최소 속도 제한\r\n        if (now - lastDropTime >= speed) {\r\n            moveBlock(0, 1);\r\n            setLastDropTime(now);\r\n        }\r\n    }, [isPlaying, moveBlock, lastDropTime, level]);\r\n\r\n    useEffect(() => {\r\n        if (!isPlaying) {\r\n            if (dropInterval) {\r\n                clearInterval(dropInterval);\r\n                setDropInterval(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const interval = setInterval(gameLoop, 16); // 약 60fps\r\n        setDropInterval(interval);\r\n\r\n        return () => {\r\n            clearInterval(interval);\r\n            setDropInterval(null);\r\n        };\r\n    }, [isPlaying, gameLoop]);\r\n\r\n    useEffect(() => {\r\n        const handleKeyPress = (e: KeyboardEvent) => {\r\n            if (!isPlaying) return;\r\n\r\n            switch (e.key) {\r\n                case 'ArrowLeft':\r\n                    moveBlock(-1, 0);\r\n                    break;\r\n                case 'ArrowRight':\r\n                    moveBlock(1, 0);\r\n                    break;\r\n                case 'ArrowDown':\r\n                    moveBlock(0, 1);\r\n                    break;\r\n                case 'ArrowUp':\r\n                    rotateBlock();\r\n                    break;\r\n                case ' ':\r\n                    hardDrop();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyPress);\r\n        return () => window.removeEventListener('keydown', handleKeyPress);\r\n    }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\r\n\r\n    // 고스트 블록 위치 계산 함수 추가\r\n    const getGhostPosition = useCallback(() => {\r\n        if (!currentBlock) return null;\r\n        let dropY = currentBlock.position.y;\r\n        while (\r\n            isValidMove({ x: currentBlock.position.x, y: dropY + 1 }, currentBlock.shape)\r\n        ) {\r\n            dropY++;\r\n        }\r\n        return { x: currentBlock.position.x, y: dropY };\r\n    }, [currentBlock, isValidMove]);\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        // 보드 그리기\r\n        for (let y = 0; y < BOARD_HEIGHT; y++) {\r\n            for (let x = 0; x < BOARD_WIDTH; x++) {\r\n                if (board[y][x]) {\r\n                    ctx.fillStyle = '#666';\r\n                    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentBlock) {\r\n            // 고스트 블럭 먼저 그리기 (반투명)\r\n            const ghostPos = getGhostPosition();\r\n            if (ghostPos) {\r\n                ctx.fillStyle = COLORS[currentBlock.type] + '80'; // 50% 투명도\r\n                for (let y = 0; y < currentBlock.shape.length; y++) {\r\n                    for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                        if (currentBlock.shape[y][x]) {\r\n                            ctx.fillRect(\r\n                                (ghostPos.x + x) * BLOCK_SIZE,\r\n                                (ghostPos.y + y) * BLOCK_SIZE,\r\n                                BLOCK_SIZE - 1,\r\n                                BLOCK_SIZE - 1\r\n                            );\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 실제 블럭 그리기\r\n            ctx.fillStyle = COLORS[currentBlock.type];\r\n            for (let y = 0; y < currentBlock.shape.length; y++) {\r\n                for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                    if (currentBlock.shape[y][x]) {\r\n                        ctx.fillRect(\r\n                            (currentBlock.position.x + x) * BLOCK_SIZE,\r\n                            (currentBlock.position.y + y) * BLOCK_SIZE,\r\n                            BLOCK_SIZE - 1,\r\n                            BLOCK_SIZE - 1\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [board, currentBlock, getGhostPosition]);\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\">\r\n            <h1 className=\"text-4xl font-bold mb-4\">테트리스</h1>\r\n            <div className=\"mb-4\">\r\n                <p className=\"text-xl\">점수: {score}</p>\r\n                <p className=\"text-sm text-gray-300\">레벨: {level}</p>\r\n                {nextBlockType && (\r\n                    <div className=\"mt-2 text-sm text-gray-300\">\r\n                        <p>다음 블럭:</p>\r\n                        <div className=\"inline-block p-2 border border-gray-400\">\r\n                            {BLOCKS[nextBlockType].map((row, y) => (\r\n                                <div key={y} className=\"flex\">\r\n                                    {row.map((cell, x) => (\r\n                                        <div\r\n                                            key={x}\r\n                                            style={{\r\n                                                width: 12,\r\n                                                height: 12,\r\n                                                backgroundColor: cell ? COLORS[nextBlockType] : 'transparent',\r\n                                                border: cell ? '1px solid #444' : '1px solid transparent'\r\n                                            }}\r\n                                        />\r\n                                    ))}\r\n                                </div>\r\n                            ))}\r\n                        </div>\r\n                    </div>\r\n                )}\r\n            </div>\r\n            <canvas\r\n                ref={canvasRef}\r\n                width={BOARD_WIDTH * BLOCK_SIZE}\r\n                height={BOARD_HEIGHT * BLOCK_SIZE}\r\n                className=\"border-2 border-gray-600\"\r\n            />\r\n            {!isPlaying && (\r\n                <button\r\n                    onClick={startGame}\r\n                    className=\"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\"\r\n                >\r\n                    {gameOver ? '다시 시작' : '게임 시작'}\r\n                </button>\r\n            )}\r\n            {gameOver && (\r\n                <div className=\"mt-4 text-red-500 text-xl\">\r\n                    게임 오버!\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default TetrisGame;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}