{"ast":null,"code":"var _jsxFileName = \"D:\\\\MyGame\\\\src\\\\components\\\\TetrisGame.tsx\",\n  _s = $RefreshSig$();\n// (생략된 import 및 기본 설정은 유지)\n\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\n\n// 테트리스 블록 타입 정의\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// 블록 모양 정의\nconst BLOCKS = {\n  I: [[1, 1, 1, 1]],\n  O: [[1, 1], [1, 1]],\n  T: [[0, 1, 0], [1, 1, 1]],\n  L: [[1, 0], [1, 0], [1, 1]],\n  J: [[0, 1], [0, 1], [1, 1]],\n  S: [[0, 1, 1], [1, 1, 0]],\n  Z: [[1, 1, 0], [0, 1, 1]]\n};\n\n// 블록 색상 정의\nconst COLORS = {\n  I: '#00f0f0',\n  O: '#f0f000',\n  T: '#a000f0',\n  L: '#f0a000',\n  J: '#0000f0',\n  S: '#00f000',\n  Z: '#f00000'\n};\n\n// 게임 보드 크기\nconst BOARD_WIDTH = 10;\nconst BOARD_HEIGHT = 20;\nconst BLOCK_SIZE = 30;\nconst TetrisGame = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const [gameOver, setGameOver] = useState(false);\n  const [score, setScore] = useState(0);\n  const [isPlaying, setIsPlaying] = useState(false);\n  const [lockDelayTimer, setLockDelayTimer] = useState(null);\n  const [dropInterval, setDropInterval] = useState(null);\n  const [lastDropTime, setLastDropTime] = useState(Date.now());\n  const [board, setBoard] = useState(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n  const [currentBlock, setCurrentBlock] = useState(null);\n  const createNewBlock = useCallback(() => {\n    const types = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\n    const type = types[Math.floor(Math.random() * types.length)];\n    const shape = BLOCKS[type];\n    setCurrentBlock({\n      type,\n      position: {\n        x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2),\n        y: 0\n      },\n      shape\n    });\n  }, []);\n  const handleGameOver = useCallback(() => {\n    setGameOver(true);\n    setIsPlaying(false);\n    setScore(0);\n  }, []);\n  const startGame = useCallback(() => {\n    setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\n    setScore(0);\n    setGameOver(false);\n    setIsPlaying(true);\n    setLastDropTime(Date.now());\n    createNewBlock();\n  }, [createNewBlock]);\n  const isValidMove = useCallback((position, shape) => {\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = position.x + x;\n          const boardY = position.y + y;\n          if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT || boardY >= 0 && board[boardY][boardX]) {\n            return false;\n          }\n        }\n      }\n    }\n    return true;\n  }, [board]);\n  const placeBlock = useCallback(() => {\n    if (!currentBlock) return;\n    const newBoard = [...board];\n    for (let y = 0; y < currentBlock.shape.length; y++) {\n      for (let x = 0; x < currentBlock.shape[y].length; x++) {\n        if (currentBlock.shape[y][x]) {\n          const boardY = currentBlock.position.y + y;\n          const boardX = currentBlock.position.x + x;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, createNewBlock, handleGameOver]);\n  const isTouchingGround = useCallback(() => {\n    if (!currentBlock) return false;\n    const testPosition = {\n      x: currentBlock.position.x,\n      y: currentBlock.position.y + 1\n    };\n    return !isValidMove(testPosition, currentBlock.shape);\n  }, [currentBlock, isValidMove]);\n  const moveBlock = useCallback((dx, dy) => {\n    if (!currentBlock || gameOver) return;\n    const newPosition = {\n      x: currentBlock.position.x + dx,\n      y: currentBlock.position.y + dy\n    };\n    if (isValidMove(newPosition, currentBlock.shape)) {\n      setCurrentBlock({\n        ...currentBlock,\n        position: newPosition\n      });\n      if (dy !== 0 && isTouchingGround()) {\n        // 이미 lockDelayTimer가 있으면 새로 만들지 않는다!\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (!isTouchingGround() && lockDelayTimer) {\n        // 바닥에서 떨어지면 타이머 취소\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    } else if (dy > 0) {\n      if (!lockDelayTimer) {\n        const timer = setTimeout(() => {\n          placeBlock();\n          setLockDelayTimer(null);\n        }, 500);\n        setLockDelayTimer(timer);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\n  const rotateBlock = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    const rotated = currentBlock.shape[0].map((_, i) => currentBlock.shape.map(row => row[i]).reverse());\n    if (isValidMove(currentBlock.position, rotated)) {\n      setCurrentBlock({\n        ...currentBlock,\n        shape: rotated\n      });\n      if (isTouchingGround()) {\n        if (!lockDelayTimer) {\n          const timer = setTimeout(() => {\n            placeBlock();\n            setLockDelayTimer(null);\n          }, 500);\n          setLockDelayTimer(timer);\n        }\n      } else if (!isTouchingGround() && lockDelayTimer) {\n        clearTimeout(lockDelayTimer);\n        setLockDelayTimer(null);\n      }\n    }\n  }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\n  const checkLines = useCallback(newBoard => {\n    let linesCleared = 0;\n    for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\n      if (newBoard[y].every(cell => cell === 1)) {\n        newBoard.splice(y, 1);\n        newBoard.unshift(Array(BOARD_WIDTH).fill(0));\n        linesCleared++;\n        y++;\n      }\n    }\n    if (linesCleared > 0) {\n      setScore(prev => prev + linesCleared * 100);\n      setBoard(newBoard);\n    }\n  }, []);\n  const hardDrop = useCallback(() => {\n    if (!currentBlock || gameOver) return;\n    let dropDistance = 0;\n    const shape = currentBlock.shape;\n    const startPosition = currentBlock.position;\n    while (isValidMove({\n      x: startPosition.x,\n      y: startPosition.y + dropDistance + 1\n    }, shape)) {\n      dropDistance++;\n    }\n    const finalPosition = {\n      x: startPosition.x,\n      y: startPosition.y + dropDistance\n    };\n    const newBoard = [...board];\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const boardX = finalPosition.x + x;\n          const boardY = finalPosition.y + y;\n          if (boardY < 0 || boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1) {\n            handleGameOver();\n            return;\n          }\n          if (boardY < BOARD_HEIGHT) {\n            newBoard[boardY][boardX] = 1;\n          }\n        }\n      }\n    }\n    setBoard(newBoard);\n    checkLines(newBoard);\n    createNewBlock();\n  }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\n  const gameLoop = useCallback(() => {\n    if (!isPlaying) return;\n    const now = Date.now();\n    if (now - lastDropTime >= 1000) {\n      moveBlock(0, 1);\n      setLastDropTime(now);\n    }\n  }, [isPlaying, moveBlock, lastDropTime]);\n  useEffect(() => {\n    if (!isPlaying) {\n      if (dropInterval) {\n        clearInterval(dropInterval);\n        setDropInterval(null);\n      }\n      return;\n    }\n    const interval = setInterval(gameLoop, 16); // 약 60fps\n    setDropInterval(interval);\n    return () => {\n      clearInterval(interval);\n      setDropInterval(null);\n    };\n  }, [isPlaying, gameLoop]);\n  useEffect(() => {\n    const handleKeyPress = e => {\n      if (!isPlaying) return;\n      switch (e.key) {\n        case 'ArrowLeft':\n          moveBlock(-1, 0);\n          break;\n        case 'ArrowRight':\n          moveBlock(1, 0);\n          break;\n        case 'ArrowDown':\n          moveBlock(0, 1);\n          break;\n        case 'ArrowUp':\n          rotateBlock();\n          break;\n        case ' ':\n          hardDrop();\n          break;\n      }\n    };\n    window.addEventListener('keydown', handleKeyPress);\n    return () => window.removeEventListener('keydown', handleKeyPress);\n  }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    for (let y = 0; y < BOARD_HEIGHT; y++) {\n      for (let x = 0; x < BOARD_WIDTH; x++) {\n        if (board[y][x]) {\n          ctx.fillStyle = '#666';\n          ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n        }\n      }\n    }\n    if (currentBlock) {\n      ctx.fillStyle = COLORS[currentBlock.type];\n      for (let y = 0; y < currentBlock.shape.length; y++) {\n        for (let x = 0; x < currentBlock.shape[y].length; x++) {\n          if (currentBlock.shape[y][x]) {\n            ctx.fillRect((currentBlock.position.x + x) * BLOCK_SIZE, (currentBlock.position.y + y) * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\n          }\n        }\n      }\n    }\n  }, [board, currentBlock]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\",\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      className: \"text-4xl font-bold mb-4\",\n      children: \"\\uD14C\\uD2B8\\uB9AC\\uC2A4\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 348,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mb-4\",\n      children: /*#__PURE__*/_jsxDEV(\"p\", {\n        className: \"text-xl\",\n        children: [\"\\uC810\\uC218: \", score]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 350,\n        columnNumber: 17\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 349,\n      columnNumber: 13\n    }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n      ref: canvasRef,\n      width: BOARD_WIDTH * BLOCK_SIZE,\n      height: BOARD_HEIGHT * BLOCK_SIZE,\n      className: \"border-2 border-gray-600\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 352,\n      columnNumber: 13\n    }, this), !isPlaying && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: startGame,\n      className: \"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\",\n      children: gameOver ? '다시 시작' : '게임 시작'\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 359,\n      columnNumber: 17\n    }, this), gameOver && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mt-4 text-red-500 text-xl\",\n      children: \"\\uAC8C\\uC784 \\uC624\\uBC84!\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 367,\n      columnNumber: 17\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 347,\n    columnNumber: 9\n  }, this);\n};\n_s(TetrisGame, \"stNawGlJUm3n78sFnzqIXhpZjUE=\");\n_c = TetrisGame;\nexport default TetrisGame;\nvar _c;\n$RefreshReg$(_c, \"TetrisGame\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useCallback","jsxDEV","_jsxDEV","BLOCKS","I","O","T","L","J","S","Z","COLORS","BOARD_WIDTH","BOARD_HEIGHT","BLOCK_SIZE","TetrisGame","_s","canvasRef","gameOver","setGameOver","score","setScore","isPlaying","setIsPlaying","lockDelayTimer","setLockDelayTimer","dropInterval","setDropInterval","lastDropTime","setLastDropTime","Date","now","board","setBoard","Array","fill","map","currentBlock","setCurrentBlock","createNewBlock","types","type","Math","floor","random","length","shape","position","x","y","handleGameOver","startGame","isValidMove","boardX","boardY","placeBlock","newBoard","checkLines","isTouchingGround","testPosition","moveBlock","dx","dy","newPosition","timer","setTimeout","clearTimeout","rotateBlock","rotated","_","i","row","reverse","linesCleared","every","cell","splice","unshift","prev","hardDrop","dropDistance","startPosition","finalPosition","gameLoop","clearInterval","interval","setInterval","handleKeyPress","e","key","window","addEventListener","removeEventListener","canvas","current","ctx","getContext","clearRect","width","height","fillStyle","fillRect","className","children","fileName","_jsxFileName","lineNumber","columnNumber","ref","onClick","_c","$RefreshReg$"],"sources":["D:/MyGame/src/components/TetrisGame.tsx"],"sourcesContent":["// (생략된 import 및 기본 설정은 유지)\r\n\r\nimport React, { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\n// 테트리스 블록 타입 정의\r\ntype BlockType = 'I' | 'O' | 'T' | 'L' | 'J' | 'S' | 'Z';\r\n\r\n// 블록 모양 정의\r\nconst BLOCKS = {\r\n    I: [[1, 1, 1, 1]],\r\n    O: [[1, 1], [1, 1]],\r\n    T: [[0, 1, 0], [1, 1, 1]],\r\n    L: [[1, 0], [1, 0], [1, 1]],\r\n    J: [[0, 1], [0, 1], [1, 1]],\r\n    S: [[0, 1, 1], [1, 1, 0]],\r\n    Z: [[1, 1, 0], [0, 1, 1]]\r\n};\r\n\r\n// 블록 색상 정의\r\nconst COLORS = {\r\n    I: '#00f0f0',\r\n    O: '#f0f000',\r\n    T: '#a000f0',\r\n    L: '#f0a000',\r\n    J: '#0000f0',\r\n    S: '#00f000',\r\n    Z: '#f00000'\r\n};\r\n\r\n// 게임 보드 크기\r\nconst BOARD_WIDTH = 10;\r\nconst BOARD_HEIGHT = 20;\r\nconst BLOCK_SIZE = 30;\r\n\r\nconst TetrisGame: React.FC = () => {\r\n    const canvasRef = useRef<HTMLCanvasElement>(null);\r\n    const [gameOver, setGameOver] = useState(false);\r\n    const [score, setScore] = useState(0);\r\n    const [isPlaying, setIsPlaying] = useState(false);\r\n    const [lockDelayTimer, setLockDelayTimer] = useState<NodeJS.Timeout | null>(null);\r\n    const [dropInterval, setDropInterval] = useState<NodeJS.Timeout | null>(null);\r\n    const [lastDropTime, setLastDropTime] = useState<number>(Date.now());\r\n\r\n    const [board, setBoard] = useState<number[][]>(\r\n        Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0))\r\n    );\r\n    const [currentBlock, setCurrentBlock] = useState<{\r\n        type: BlockType;\r\n        position: { x: number; y: number };\r\n        shape: number[][];\r\n    } | null>(null);\r\n\r\n    const createNewBlock = useCallback(() => {\r\n        const types: BlockType[] = ['I', 'O', 'T', 'L', 'J', 'S', 'Z'];\r\n        const type = types[Math.floor(Math.random() * types.length)];\r\n        const shape = BLOCKS[type];\r\n\r\n        setCurrentBlock({\r\n            type,\r\n            position: { x: Math.floor(BOARD_WIDTH / 2) - Math.floor(shape[0].length / 2), y: 0 },\r\n            shape\r\n        });\r\n    }, []);\r\n\r\n    const handleGameOver = useCallback(() => {\r\n        setGameOver(true);\r\n        setIsPlaying(false);\r\n        setScore(0);\r\n    }, []);\r\n\r\n    const startGame = useCallback(() => {\r\n        setBoard(Array(BOARD_HEIGHT).fill(null).map(() => Array(BOARD_WIDTH).fill(0)));\r\n        setScore(0);\r\n        setGameOver(false);\r\n        setIsPlaying(true);\r\n        setLastDropTime(Date.now());\r\n        createNewBlock();\r\n    }, [createNewBlock]);\r\n\r\n    const isValidMove = useCallback((position: { x: number; y: number }, shape: number[][]) => {\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = position.x + x;\r\n                    const boardY = position.y + y;\r\n\r\n                    if (\r\n                        boardX < 0 ||\r\n                        boardX >= BOARD_WIDTH ||\r\n                        boardY >= BOARD_HEIGHT ||\r\n                        (boardY >= 0 && board[boardY][boardX])\r\n                    ) {\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }, [board]);\r\n\r\n    const placeBlock = useCallback(() => {\r\n        if (!currentBlock) return;\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < currentBlock.shape.length; y++) {\r\n            for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                if (currentBlock.shape[y][x]) {\r\n                    const boardY = currentBlock.position.y + y;\r\n                    const boardX = currentBlock.position.x + x;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, createNewBlock, handleGameOver]);\r\n\r\n    const isTouchingGround = useCallback(() => {\r\n        if (!currentBlock) return false;\r\n        const testPosition = {\r\n            x: currentBlock.position.x,\r\n            y: currentBlock.position.y + 1\r\n        };\r\n        return !isValidMove(testPosition, currentBlock.shape);\r\n    }, [currentBlock, isValidMove]);\r\n\r\n    const moveBlock = useCallback((dx: number, dy: number) => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const newPosition = {\r\n            x: currentBlock.position.x + dx,\r\n            y: currentBlock.position.y + dy\r\n        };\r\n\r\n        if (isValidMove(newPosition, currentBlock.shape)) {\r\n            setCurrentBlock({ ...currentBlock, position: newPosition });\r\n\r\n            if (dy !== 0 && isTouchingGround()) {\r\n                // 이미 lockDelayTimer가 있으면 새로 만들지 않는다!\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (!isTouchingGround() && lockDelayTimer) {\r\n                // 바닥에서 떨어지면 타이머 취소\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        } else if (dy > 0) {\r\n            if (!lockDelayTimer) {\r\n                const timer = setTimeout(() => {\r\n                    placeBlock();\r\n                    setLockDelayTimer(null);\r\n                }, 500);\r\n                setLockDelayTimer(timer);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, placeBlock, lockDelayTimer, isTouchingGround]);\r\n\r\n    const rotateBlock = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        const rotated = currentBlock.shape[0].map((_, i) =>\r\n            currentBlock.shape.map(row => row[i]).reverse()\r\n        );\r\n\r\n        if (isValidMove(currentBlock.position, rotated)) {\r\n            setCurrentBlock({ ...currentBlock, shape: rotated });\r\n\r\n            if (isTouchingGround()) {\r\n                if (!lockDelayTimer) {\r\n                    const timer = setTimeout(() => {\r\n                        placeBlock();\r\n                        setLockDelayTimer(null);\r\n                    }, 500);\r\n                    setLockDelayTimer(timer);\r\n                }\r\n            } else if (!isTouchingGround() && lockDelayTimer) {\r\n                clearTimeout(lockDelayTimer);\r\n                setLockDelayTimer(null);\r\n            }\r\n        }\r\n    }, [currentBlock, gameOver, isValidMove, lockDelayTimer, isTouchingGround, placeBlock]);\r\n\r\n    const checkLines = useCallback((newBoard: number[][]) => {\r\n        let linesCleared = 0;\r\n\r\n        for (let y = BOARD_HEIGHT - 1; y >= 0; y--) {\r\n            if (newBoard[y].every(cell => cell === 1)) {\r\n                newBoard.splice(y, 1);\r\n                newBoard.unshift(Array(BOARD_WIDTH).fill(0));\r\n                linesCleared++;\r\n                y++;\r\n            }\r\n        }\r\n\r\n        if (linesCleared > 0) {\r\n            setScore(prev => prev + linesCleared * 100);\r\n            setBoard(newBoard);\r\n        }\r\n    }, []);\r\n\r\n    const hardDrop = useCallback(() => {\r\n        if (!currentBlock || gameOver) return;\r\n\r\n        let dropDistance = 0;\r\n        const shape = currentBlock.shape;\r\n        const startPosition = currentBlock.position;\r\n\r\n        while (isValidMove({ x: startPosition.x, y: startPosition.y + dropDistance + 1 }, shape)) {\r\n            dropDistance++;\r\n        }\r\n\r\n        const finalPosition = {\r\n            x: startPosition.x,\r\n            y: startPosition.y + dropDistance\r\n        };\r\n\r\n        const newBoard = [...board];\r\n        for (let y = 0; y < shape.length; y++) {\r\n            for (let x = 0; x < shape[y].length; x++) {\r\n                if (shape[y][x]) {\r\n                    const boardX = finalPosition.x + x;\r\n                    const boardY = finalPosition.y + y;\r\n\r\n                    if (boardY < 0 || (boardY < BOARD_HEIGHT && newBoard[boardY][boardX] === 1)) {\r\n                        handleGameOver();\r\n                        return;\r\n                    }\r\n\r\n                    if (boardY < BOARD_HEIGHT) {\r\n                        newBoard[boardY][boardX] = 1;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        setBoard(newBoard);\r\n        checkLines(newBoard);\r\n        createNewBlock();\r\n    }, [currentBlock, board, gameOver, isValidMove, handleGameOver, checkLines, createNewBlock]);\r\n\r\n    const gameLoop = useCallback(() => {\r\n        if (!isPlaying) return;\r\n\r\n        const now = Date.now();\r\n        if (now - lastDropTime >= 1000) {\r\n            moveBlock(0, 1);\r\n            setLastDropTime(now);\r\n        }\r\n    }, [isPlaying, moveBlock, lastDropTime]);\r\n\r\n    useEffect(() => {\r\n        if (!isPlaying) {\r\n            if (dropInterval) {\r\n                clearInterval(dropInterval);\r\n                setDropInterval(null);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const interval = setInterval(gameLoop, 16); // 약 60fps\r\n        setDropInterval(interval);\r\n\r\n        return () => {\r\n            clearInterval(interval);\r\n            setDropInterval(null);\r\n        };\r\n    }, [isPlaying, gameLoop]);\r\n\r\n    useEffect(() => {\r\n        const handleKeyPress = (e: KeyboardEvent) => {\r\n            if (!isPlaying) return;\r\n\r\n            switch (e.key) {\r\n                case 'ArrowLeft':\r\n                    moveBlock(-1, 0);\r\n                    break;\r\n                case 'ArrowRight':\r\n                    moveBlock(1, 0);\r\n                    break;\r\n                case 'ArrowDown':\r\n                    moveBlock(0, 1);\r\n                    break;\r\n                case 'ArrowUp':\r\n                    rotateBlock();\r\n                    break;\r\n                case ' ':\r\n                    hardDrop();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        window.addEventListener('keydown', handleKeyPress);\r\n        return () => window.removeEventListener('keydown', handleKeyPress);\r\n    }, [isPlaying, moveBlock, rotateBlock, hardDrop]);\r\n\r\n    useEffect(() => {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) return;\r\n\r\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n\r\n        for (let y = 0; y < BOARD_HEIGHT; y++) {\r\n            for (let x = 0; x < BOARD_WIDTH; x++) {\r\n                if (board[y][x]) {\r\n                    ctx.fillStyle = '#666';\r\n                    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (currentBlock) {\r\n            ctx.fillStyle = COLORS[currentBlock.type];\r\n            for (let y = 0; y < currentBlock.shape.length; y++) {\r\n                for (let x = 0; x < currentBlock.shape[y].length; x++) {\r\n                    if (currentBlock.shape[y][x]) {\r\n                        ctx.fillRect(\r\n                            (currentBlock.position.x + x) * BLOCK_SIZE,\r\n                            (currentBlock.position.y + y) * BLOCK_SIZE,\r\n                            BLOCK_SIZE - 1,\r\n                            BLOCK_SIZE - 1\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [board, currentBlock]);\r\n\r\n    return (\r\n        <div className=\"flex flex-col items-center justify-center min-h-screen bg-gray-900 text-white\">\r\n            <h1 className=\"text-4xl font-bold mb-4\">테트리스</h1>\r\n            <div className=\"mb-4\">\r\n                <p className=\"text-xl\">점수: {score}</p>\r\n            </div>\r\n            <canvas\r\n                ref={canvasRef}\r\n                width={BOARD_WIDTH * BLOCK_SIZE}\r\n                height={BOARD_HEIGHT * BLOCK_SIZE}\r\n                className=\"border-2 border-gray-600\"\r\n            />\r\n            {!isPlaying && (\r\n                <button\r\n                    onClick={startGame}\r\n                    className=\"mt-4 px-6 py-2 bg-blue-500 hover:bg-blue-600 rounded-lg\"\r\n                >\r\n                    {gameOver ? '다시 시작' : '게임 시작'}\r\n                </button>\r\n            )}\r\n            {gameOver && (\r\n                <div className=\"mt-4 text-red-500 text-xl\">\r\n                    게임 오버!\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default TetrisGame;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}